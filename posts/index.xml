<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Run</title>
		<link>https://LeiBuDao.github.io/posts/</link>
		<description>Recent content in Posts on Run</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 12 Mar 2022 13:38:13 +0800</lastBuildDate>
		<atom:link href="https://LeiBuDao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Promise学习笔记</title>
			<link>https://LeiBuDao.github.io/posts/promise_study/</link>
			<pubDate>Sat, 12 Mar 2022 13:38:13 +0800</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/promise_study/</guid>
			<description>#目录  [TOC]
 一、Promise的理解与使用  1、概念:
​	Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。
 Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了  ​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败
​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果
Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await
2、特点:
​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。
3、缺点:
​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。
​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
  1、Promise是什么? Ⅰ-理解   抽象表达:  ​	1) Promise 是一门新的技术(ES6 规范)
​	2)Promise 是 JS 中进行异步编程的新解决方案
​	备注：旧方案是单纯使用回调函数
具体表达:    从语法上来说: Promise 是一个构造函数
  从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</description>
			<content type="html"><![CDATA[<h1 id="目录">#目录</h1>
<blockquote>
<p>[TOC]</p>
</blockquote>
<h1 id="一promise的理解与使用">一、Promise的理解与使用</h1>
<blockquote>
<p>1、概念:</p>
<p>​	Promise是<code>异步编程的一种解决方案</code>，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>通俗讲，<code>Promise是一个许诺、承诺</code>,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。</p>
<ul>
<li>Pending  正在做。。。</li>
<li>Resolved 完成这个承诺</li>
<li>Rejected 这个承诺没有完成，失败了</li>
</ul>
<p>​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败</p>
<p>​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果</p>
<p>Promise 是异步编程的一种解决方案，<code>主要用来解决回调地狱的问题，可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p>
<p>2、特点:</p>
<p>​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p>
<p>3、缺点:</p>
<p>​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。</p>
<p>​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p>
<p>​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
</blockquote>
<hr>
<h2 id="1promise是什么">1、Promise是什么?</h2>
<h4 id="-理解">Ⅰ-理解</h4>
<blockquote>
<ol>
<li>抽象表达:</li>
</ol>
<p>​	1) Promise 是一门新的技术(ES6 规范)</p>
<p>​	2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案</p>
<p>​		备注：旧方案是单纯使用回调函数</p>
<ol start="2">
<li>具体表达:</li>
</ol>
<ol>
<li>
<p>从语法上来说: Promise 是一个<code>构造函数</code></p>
</li>
<li>
<p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p>
</li>
</ol>
</blockquote>
<h4 id="-promise-的状态">Ⅱ-promise 的状态</h4>
<h5 id="a-promise-的状态">a) promise 的状态</h5>
<blockquote>
<p>实例对象中的一个属性 『PromiseState』</p>
<ul>
<li>pending  未决定的</li>
<li>resolved / fullfilled  成功</li>
<li>rejected  失败</li>
</ul>
</blockquote>
<h5 id="b-promise-的状态改变">b) promise 的状态改变</h5>
<blockquote>
<ol>
<li>
<p>pending 变为 resolved</p>
</li>
<li>
<p>pending 变为 rejected</p>
</li>
</ol>
<p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次；</p>
<p>​			无论变为成功还是失败, 都会有一个结果数据 ；</p>
<p>​			成功的结果数据一般称为 value, 失败的结果数据一般称为 reason。</p>
</blockquote>
<h4 id="-promise的基本流程">Ⅲ-promise的基本流程</h4>
<blockquote>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_promise%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Promise系统学习_promise工作流程"></p>
</blockquote>
<h4 id="-promise的基本使用">Ⅳ-promise的基本使用</h4>
<h6 id="1使用-promise-封装基于定时器的异步">1.使用 promise 封装基于定时器的异步</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">script</span> <span class="o">&gt;</span>
  <span class="kd">function</span> <span class="nx">doDelay</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 创建 promise 对象(pending 状态), 指定执行器函数
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 2. 在执行器函数中启动异步任务
</span><span class="c1"></span>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;启动异步任务&#39;</span><span class="p">)</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;延迟任务开始执行...&#39;</span><span class="p">)</span>
            <span class="kr">const</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="c1">// 假设: 时间为奇数代表成功, 为偶数代表失败
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">time</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 成功了
</span><span class="c1"></span>            <span class="c1">// 3.1. 如果成功了, 调用 resolve()并传入成功的 value
</span><span class="c1"></span>                <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功的数据 &#39;</span> <span class="o">+</span> <span class="nx">time</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 失败了
</span><span class="c1"></span>            <span class="c1">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason
</span><span class="c1"></span>                <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;失败的数据 &#39;</span> <span class="o">+</span> <span class="nx">time</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">},</span> <span class="nx">time</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doDelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="c1">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason
</span><span class="c1"></span>    <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">// 成功的回调函数 onResolved, 得到成功的 vlaue
</span><span class="c1"></span>    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功的 value: &#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="c1">// 失败的回调函数 onRejected, 得到失败的 reason
</span><span class="c1"></span>    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败的 reason: &#39;</span><span class="p">,</span> <span class="nx">reason</span><span class="p">)</span>
    <span class="p">},</span>
  <span class="p">)</span> 
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div><h6 id="2使用-promise-封装-ajax-异步请求">2.使用 promise 封装 ajax 异步请求</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">script</span> <span class="o">&gt;</span>
  <span class="cm">/*
</span><span class="cm">  可复用的发 ajax 请求的函数: xhr + promise
</span><span class="cm">  */</span>
  <span class="kd">function</span> <span class="nx">promiseAjax</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">()</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">!==</span> <span class="mi">4</span><span class="p">)</span> <span class="k">return</span>
        <span class="kr">const</span> <span class="p">{</span>
          <span class="nx">status</span><span class="p">,</span>
          <span class="nx">response</span>
        <span class="p">}</span> <span class="o">=</span> <span class="nx">xhr</span>
        <span class="c1">// 请求成功, 调用 resolve(value)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 请求失败, 调用 reject(reason)
</span><span class="c1"></span>          <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;请求失败: status: &#39;</span> <span class="o">+</span> <span class="nx">status</span><span class="p">))</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="nx">promiseAjax</span><span class="p">(</span><span class="s1">&#39;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=video &#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;显示成功数据&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span> 
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div><h6 id="3fs模块使用promise">3.fs模块使用Promise</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="c1">//回调函数 形式----------------------------------------------------
</span><span class="c1"></span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
     <span class="c1">// 如果出错 则抛出错误
</span><span class="c1"></span>     <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>  <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
     <span class="c1">//输出文件内容
</span><span class="c1"></span>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
 <span class="p">});</span>

<span class="c1">//Promise 形式-----------------------------------------------------------
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm"> * 封装一个函数 mineReadFile 读取文件内容
</span><span class="cm"> * 参数:  path  文件路径
</span><span class="cm"> * 返回:  promise 对象
</span><span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">mineReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//读取文件
</span><span class="c1"></span>        <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">).</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;{</span>
            <span class="c1">//判断
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
            <span class="c1">//成功
</span><span class="c1"></span>            <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span><span class="p">=&gt;{</span>
    <span class="c1">//输出文件内容
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">},</span> <span class="nx">reason</span><span class="p">=&gt;{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div><h6 id="4异常穿透">4.异常穿透</h6>
<blockquote>
<p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p>
<p>在每个.then()中我可以将数据再次传出给下一个then()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./11.txt&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span><span class="p">=&gt;{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">},</span><span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span><span class="s2">&#34;2222222&#34;</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;这是catch的&#34;</span><span class="p">))</span>
</code></pre></div><h6 id="5utilpromisify方法">5.<code>util.promisify方法</code></h6>
<blockquote>
<p>可以将函数直接变成promise的封装方式,不用再去手动封装</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">//引入 util 模块
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">);</span>
<span class="c1">//引入 fs 模块
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="c1">//返回一个新的函数
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">mineReadFile</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">promisify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>

<span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div><hr>
<h2 id="2为什么要用promise">2、为什么要用Promise?</h2>
<h3 id="-指定回调函数的方式更加灵活">Ⅰ-指定回调函数的方式更加灵活</h3>
<blockquote>
<ol>
<li>旧的: 必须在启动异步任务前指定</li>
<li>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个)</li>
</ol>
</blockquote>
<h3 id="-支持链式调用-可以解决回调地狱问题">Ⅱ-支持链式调用, 可以解决回调地狱问题</h3>
<h5 id="1什么是回调地狱">1、什么是回调地狱</h5>
<blockquote>
<p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p>
</blockquote>
<h5 id="2回调地狱的缺点">2、回调地狱的缺点?</h5>
<blockquote>
<p>不便于阅读 不便于异常处理</p>
</blockquote>
<h5 id="3解决方案">3、解决方案?</h5>
<blockquote>
<p>promise <code>链式调用</code>,</p>
<p>用来解决回调地狱问题，但是<code>只是简单的改变格式</code>，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">finalResult</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got the final result: &#39;</span> <span class="o">+</span> <span class="nx">finalResult</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">failureCallback</span><span class="p">)</span>
</code></pre></div></blockquote>
<h5 id="4终极解决方案">4、终极解决方案?</h5>
<blockquote>
<p>promise +async/await</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">request</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">try</span> <span class="p">{</span>
     <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doSomething</span><span class="p">()</span>
     <span class="kr">const</span> <span class="nx">newResult</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
     <span class="kr">const</span> <span class="nx">finalResult</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span>
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got the final result: &#39;</span> <span class="o">+</span> <span class="nx">finalResult</span><span class="p">)</span> 
 <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">failureCallback</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> 
 <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></blockquote>
<hr>
<h2 id="3promise中的常用-api-概述">3、Promise中的常用 API 概述</h2>
<blockquote>
<p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p>
</blockquote>
<h4 id="--promise-构造函数-promise-excutor">Ⅰ- Promise 构造函数: Promise (excutor)</h4>
<blockquote>
<p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p>
<p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p>
<p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p>
<p>说明: executor 会在 Promise 内部立即<code>同步调用</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p>
</blockquote>
<h4 id="-promiseprototypethen-方法-onresolved-onrejected-">Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt;</h4>
<blockquote>
<p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}</p>
<p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p>
<p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p>
</blockquote>
<h4 id="-promiseprototypecatch-方法-onrejected-">Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt;</h4>
<blockquote>
<p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p>
<p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
<p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中</p>
</blockquote>
<h4 id="-promiseresolve-方法-value-">Ⅳ-Promise.resolve 方法: (value) =&gt;</h4>
<blockquote>
<p>value: 成功的数据或 promise 对象</p>
<p>说明: 返回一个成功/失败的 promise 对象,直接改变promise状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">521</span><span class="p">);</span>
<span class="c1">//如果传入的参数为 非Promise类型的对象, 则返回的结果为成功的Promise对象
</span><span class="c1"></span>
<span class="c1">//如果传入的参数为 Promise 对象, 返回的结果为传入的Promise对象的返回结果，返回的值为传入的Promise对象的值。
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// resolve(&#39;OK&#39;);
</span><span class="c1"></span>  <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
<span class="p">}));</span>
<span class="c1">// console.log(p2);
</span><span class="c1"></span><span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></blockquote>
<h4 id="-promisereject-方法-reason-">Ⅴ-Promise.reject 方法: (reason) =&gt;</h4>
<blockquote>
<p>reason: 失败的原因</p>
<p>说明: 返回一个失败的 promise 对象,直接改变promise状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">521</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;iloveyou&#39;</span><span class="p">);</span>
<span class="c1">//如果传入的参数为 非Promise类型的对象, 则返回的结果为失败的promise对象
</span><span class="c1">//如果传入的参数为 Promise 对象, 返回的结果为&#34;rejected&#34;，且失败的值为传入的promise参数
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
<span class="p">}));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p3</span><span class="p">);</span>
</code></pre></div></blockquote>
<h4 id="-promiseall-方法-promises-">Ⅵ-Promise.all 方法: (promises) =&gt;</h4>
<blockquote>
<p>promises: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, 只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败。成功的结果为所有Promise对象结果组成的数组，而失败的结果为第一个[根据传入参数的顺序]失败的对象的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>  
<span class="p">})</span>
<span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;错误错误错误&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;也是成功&#39;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></blockquote>
<h4 id="-promiserace-方法-promises-">Ⅶ-Promise.race 方法: (promises) =&gt;</h4>
<blockquote>
<p>promises: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, <code>第一个完成</code>的 promise 的结果状态就是最终的结果状态,</p>
<p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
       <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">})</span>
<span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
<span class="c1">//调用
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></blockquote>
<hr>
<h2 id="4promise的几个关键问题">4、Promise的几个关键问题</h2>
<h4 id="-如何改变-promise-的状态">Ⅰ-如何改变 promise 的状态?</h4>
<blockquote>
<p>(1) resolve(value): 如果当前是 pending 就会变为 resolved (fullfiled)</p>
<p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p>
<p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p>
</blockquote>
<h4 id="-一个-promise-指定多个成功失败回调函数-都会调用吗">Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?</h4>
<blockquote>
<p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">///指定回调1
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> 
<span class="p">});</span>

<span class="c1">//指定回调2
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></blockquote>
<h4 id="--改变-promise-状态和指定回调函数谁先谁后">Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?</h4>
<blockquote>
<p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p>
<p>​	①先指定回调再改变状态(<code>异步</code>):先指定回调&ndash;&gt; 再改变状态 &ndash;&gt;改变状态后才进入异步队列执行回调函数</p>
<p>​	② 先改状态再指定回调(<code>同步</code>):改变状态 &ndash;&gt;指定回调 ,<code>并马上执行</code>回调</p>
<p>(2) 如何先改状态再<code>指定</code>回调?   &ndash;&gt; 注意:指定并不是执行</p>
<p>​	① 在执行器中直接调用 resolve()/reject() &ndash;&gt;即,不使用定时器等方法,执行器内直接同步操作</p>
<p>​	② 延迟更长时间才调用 then() 	&ndash;&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p>
<p>(3) 什么时候才能得到数据?</p>
<p>​	① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p>
<p>​	② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="c1">//异步写法,这样写会先指定回调,再改变状态
</span><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">//这是同步写法,这样写会先改变状态,再指定回调
</span><span class="c1"></span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
<span class="p">});</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>    
<span class="p">})</span>
</code></pre></div><p>(4) 个人理解&ndash;结合源码</p>
<p>​          源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断,所以当<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后。这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功。所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的。具体代码实现看下方自定义promise。</p>
</blockquote>
<h4 id="-promisethen返回的新-promise-的结果状态由什么决定">Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4>
<blockquote>
<p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p>
<p>(2) 详细表达:</p>
<p>​	① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</p>
<p>​	② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p>
<p>​	③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//执行 then 方法
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="c1">// 1. 抛出异常 ,变为 rejected
</span><span class="c1">// throw &#39;出了问题&#39;;
</span><span class="c1"></span>
<span class="c1">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved
</span><span class="c1">// return 521;
</span><span class="c1"></span>
<span class="c1">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果
</span><span class="c1"></span>  <span class="c1">//return new Promise((resolve, reject) =&gt; {
</span><span class="c1"></span>  	<span class="c1">// resolve(&#39;success&#39;);
</span><span class="c1"></span>  	<span class="c1">// reject(&#39;error&#39;);
</span><span class="c1"></span><span class="p">});</span>
<span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></blockquote>
<h4 id="--promise-如何串连多个操作任务">Ⅴ- promise 如何串连多个操作任务?</h4>
<blockquote>
<p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 。</p>
<p>(2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span> 
<span class="p">});</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;success&#34;</span><span class="p">);</span> 
<span class="p">});</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">})</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">//输出结果：
</span><span class="c1">//success
</span><span class="c1">//undefined
</span><span class="c1"></span>
<span class="c1">//分析：第二个then函数中应当返回一个promise对象，但是没有返回值，默认为undefined，因此第三个回调函数输出一个undefined.
</span></code></pre></div></blockquote>
<h4 id="-promise-异常传透">Ⅵ-promise 异常传透?</h4>
<blockquote>
<ul>
<li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li>
<li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">),</span><span class="nx">e</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;被then的错误回调捕获&#39;</span><span class="p">,</span><span class="nx">e</span><span class="p">)</span> <span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//执行结果: 被then的错误回调捕获 Error: 抛出异常
</span><span class="c1"></span>

<span class="cm">/******************** 利用异常穿透 ****************************************/</span>
<span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//此处差异,不指定 reject 回调,利用异常穿透传到最后
</span><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//执行结果:  错误捕获:  Error: 抛出异常
</span></code></pre></div><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../image/Promise_study/image-20210927105504988.png" alt="image-20210927105504988"></p>
</blockquote>
<h4 id="--中断-promise-链">Ⅶ- 中断 promise 链?</h4>
<blockquote>
<p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p>
<p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>  
<span class="p">});</span>
<span class="p">})</span><span class="c1">//有且只有这一个方式
</span><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">});</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div></blockquote>
<hr>
<h2 id="5-promise的实际应用">5、 Promise的实际应用</h2>
<blockquote>
<p>举两个小栗子</p>
</blockquote>
<h3 id="---加载图片">Ⅰ - 加载图片</h3>
<blockquote>
<p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">preloadImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
      <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span>  <span class="o">=</span> <span class="nx">resolve</span><span class="p">;</span>
      <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
      <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">path</span><span class="p">;</span>
<span class="p">});</span>
<span class="p">};</span>
</code></pre></div></blockquote>
<h3 id="---generator-函数与-promise-的结合">Ⅱ - Generator 函数与 Promise 的结合</h3>
<blockquote>
<p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getFoo</span> <span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="p">});</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
<span class="k">try</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getFoo</span><span class="p">();</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">run</span> <span class="p">(</span><span class="nx">generator</span><span class="p">)</span> <span class="p">{</span>
<span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>
<span class="kd">function</span> <span class="nx">go</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
      <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
      <span class="p">});</span>
   <span class="p">}</span>
  <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span>
</code></pre></div><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
</blockquote>
<hr>
<h1 id="二promise-api-用法详解">二、Promise API 用法详解</h1>
<blockquote>
<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p>
</blockquote>
<h2 id="----基本用法">Ⅰ -  基本用法</h2>
<h4 id="--举个创造-promise-实例的栗子">①  举个创造 Promise 实例的栗子</h4>
<blockquote>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">)</span>  <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//将该 Promise 修改为成功且返回
</span><span class="c1"></span> <span class="k">else</span>  <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span> <span class="c1">//将该 Promise 修改为失败且返回
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
</blockquote>
<h4 id="-使用--then--方法分别指定-成功失败-的回调">② 使用 [ then ] 方法分别指定 成功/失败 的回调</h4>
<blockquote>
<p><code>Promise</code>实例生成以后，可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 当promise状态返回为resolve 时会执行的回调函数
</span><span class="c1"></span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 当promise状态返回为rejected 时会执行的回调函数
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的，不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
</blockquote>
<h4 id="-举个-promise-对象的简单栗子">③ 举个 Promise 对象的简单栗子</h4>
<blockquote>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<blockquote>
<p>setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//声明一个方法, 传入的 参数ms 为延时器时间
</span><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="c1">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#39;努力学习的汪&#39;)
</span><span class="c1"></span>      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">,</span> <span class="s1">&#39;努力学习的汪&#39;</span><span class="p">);</span> 
  <span class="p">});</span>
<span class="p">}</span>

<span class="nx">timeout</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>  
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
<span class="p">});</span>
<span class="c1">//打印结果 : 努力学习的汪
</span></code></pre></div><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
</blockquote>
<h4 id="-promise-新建后就会立即执行">④ Promise 新建后就会立即执行</h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise&#39;</span><span class="p">);</span>
<span class="nx">resolve</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;resolved.&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi!&#39;</span><span class="p">);</span>

<span class="c1">// Promise
</span><span class="c1">// Hi!
</span><span class="c1">// resolved //可以发现,明明then是在 Hi 前面,却最后打印
</span></code></pre></div><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为:</p>
<ol>
<li>
<p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p>
</li>
<li>
<p>为何 resolve() 运行后没有立即打印?</p>
</li>
</ol>
<ul>
<li>
<p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p>
<blockquote>
<p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</p>
<p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</p>
</blockquote>
</li>
<li>
<p>JS执行时会区别这2个队列:</p>
<blockquote>
<p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p>
<p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="-举个异步加载图片的栗子">⑤ 举个异步加载图片的栗子</h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">loadImageAsync</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;图片加载成功&#39;</span><span class="p">)</span>
       <span class="nx">resolve</span><span class="p">(</span><span class="nx">image</span><span class="p">);</span>
   <span class="p">};</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`无法从 </span><span class="si">${</span><span class="nx">url</span><span class="si">}</span><span class="sb"> 中加载图片`</span> <span class="p">));</span>
  <span class="p">};</span>
   <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
<span class="p">});</span>
<span class="p">}</span>
<span class="nx">loadImageAsync</span><span class="p">(</span><span class="s1">&#39;正确的url&#39;</span><span class="p">)</span> <span class="c1">//打印图片加载成功
</span><span class="c1"></span><span class="nx">loadImageAsync</span><span class="p">(</span><span class="s1">&#39;错误的url&#39;</span><span class="p">)</span> <span class="c1">//抛出异常
</span></code></pre></div><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p><img src="../../image/Promise_study/image-20210926180306961.png" alt="image-20210926180306961"></p>
</blockquote>
<h4 id="-举个用promise对象实现的-ajax-操作的栗子">⑥ 举个用<code>Promise</code>对象实现的 Ajax 操作的栗子</h4>
<blockquote>
<p>Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 &ndash;&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
<span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">!==</span> <span class="mi">4</span><span class="p">)</span>  <span class="k">return</span><span class="p">;</span> <span class="c1">//当readyState 为4 时直接返回,不修改 promise 状态
</span><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span> <span class="c1">//返回状态为 200 时将状态修改为成功,且将响应内容返回
</span><span class="c1"></span>        <span class="k">else</span>  <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statusText</span><span class="p">));</span> <span class="c1">//失败时抛出异常
</span><span class="c1"></span><span class="p">};</span>
  <span class="kr">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span> <span class="c1">//实例化xml实例
</span><span class="c1"></span>  <span class="nx">client</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span> <span class="c1">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点
</span><span class="c1"></span>  <span class="nx">client</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
  <span class="nx">client</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&#34;json&#34;</span><span class="p">;</span>
  <span class="nx">client</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">&#34;Accept&#34;</span><span class="p">,</span> <span class="s2">&#34;application/json&#34;</span><span class="p">);</span>
  <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
<span class="p">});</span>
<span class="k">return</span> <span class="nx">promise</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Contents: &#39;</span> <span class="p">,</span> <span class="nx">json</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p><img src="../../image/Promise_study/image-20210926182129672.png" alt="image-20210926182129672"></p>
<blockquote>
<p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p>
</blockquote>
<blockquote>
<p><img src="../../image/Promise_study/image-20210926182506259.png" alt="image-20210926182506259"></p>
</blockquote>
</blockquote>
<h4 id="--resolve--的参数可以是另一个-promise-实例">⑦  resolve()  的参数可以是另一个 Promise 实例</h4>
<blockquote>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{});</span>

<span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="p">})</span>
</code></pre></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;p1的状态改为错误&#39;</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">})</span>

<span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">),</span> <span class="mi">3000</span><span class="p">)</span> <span class="c1">//将p1 传给p2
</span><span class="c1"></span><span class="p">})</span>

<span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">),</span><span class="nx">result</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败&#39;</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch异常捕获:&#39;</span><span class="o">+</span><span class="nx">error</span><span class="p">))</span>
<span class="c1">//首先报错
</span><span class="c1">//运行三秒后打印: 失败
</span></code></pre></div><h5 id="上面代码运行后执行效果">上面代码运行后执行效果:</h5>
<ul>
<li>首先马上会打印一个报错 : &ldquo;Uncaught (in promise) Error: p1的状态改为错误&rdquo; (红色报错)</li>
<li>然后等3秒后再打印:  &lsquo;失败&rsquo;</li>
<li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li>
</ul>
<h5 id="解释">解释:</h5>
<blockquote>
<ul>
<li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li>
<li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态</li>
<li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li>
</ul>
</blockquote>
</blockquote>
<h4 id="-调用resolve或reject并不会终结-promise-的参数函数的执行">⑧ 调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</h4>
<blockquote>
<p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 2
</span><span class="c1">// 1
</span></code></pre></div><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
</blockquote>
<h4 id="-建议在修改状态函数前加return">⑨ 建议在修改状态函数前加return</h4>
<blockquote>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// 后面的语句不会执行
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p>
</blockquote>
<h5 id="a-不加-return-导致的错误场景举">a) 不加 return 导致的错误场景举🌰</h5>
<blockquote>
<p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch())</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功了&#39;</span><span class="p">);</span> <span class="c1">//如果你加了 return , 函数执行到此步就停止了
</span><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;错误错误!!!!!&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
<span class="p">});</span>
<span class="c1">// ok
</span><span class="c1">// Uncaught Error: 错误错误!!!!
</span></code></pre></div><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
</blockquote>
<h2 id="----api-用法详解">Ⅱ -  API 用法详解</h2>
<blockquote>
<p>此处将对于所有API进行详细剖析,参照资料为 <a href="">阮一峰的ES6日志</a></p>
</blockquote>
<h4 id="-promiseprototypethen">① Promise.prototype.then()</h4>
<blockquote>
<p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
</blockquote>
<h5 id="a-then方法返回的是一个新的promise实例">a) <code>then</code>方法返回的是一个新的<code>Promise</code>实例</h5>
<blockquote>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`My name is </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span> <span class="p">)</span>
<span class="p">});</span>
</code></pre></div><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
</blockquote>
<h5 id="b-采用链式的then-会等待前一个promise状态发生改变才会被调用">b) 采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用</h5>
<blockquote>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span> 
<span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;resolved: My name is &#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">},</span> 
<span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">){</span> 
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">);</span>
</code></pre></div><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
</blockquote>
<h5 id="c-使用箭头函数简写">c) 使用箭头函数简写</h5>
<blockquote>
<p>如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span> <span class="p">=&gt;</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="nx">name</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;resolved: My name is &#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">),</span> 
<span class="nx">err</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></blockquote>
<h4 id="-promiseprototypecatch">② Promise.prototype.catch()</h4>
<blockquote>
<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
</blockquote>
<h5 id="a-基本用法">a) 基本用法</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;发生错误！&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象</p>
<blockquote>
<ul>
<li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；</li>
<li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误</li>
<li>另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</li>
<li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;指定成功回调:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;在catch中进行 rejected 的处理&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">));</span>
<span class="c1">// 等同于
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;指定成功回调:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;等同于另起一个then,只指定 rejected 的处理&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">));</span>
</code></pre></div></blockquote>
<h5 id="b--reject方法的作用等同于抛出错误">b)  <code>reject()</code>方法的作用，等同于抛出错误</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;直接抛出错误&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;异常捕获: &#39;</span><span class="p">,</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//异常捕获:  Error: 直接抛出错误
</span></code></pre></div><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/******************  写法一 ***************************************/</span>
<span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;直接抛出错误&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;进入catch,然后再用 reject(e)抛出 &#39;</span><span class="p">)</span>
  <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> 
<span class="p">}</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//进入catch,然后再用 reject(e)抛出 
</span><span class="c1">//Error: 直接抛出错误
</span><span class="c1"></span>
<span class="cm">/******************  写法二 ***************************************/</span>
<span class="kr">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;使用 reject() 抛出错误&#39;</span><span class="p">));</span>
<span class="p">});</span>

<span class="nx">promise1</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//Error: 使用 reject() 抛出错误
</span></code></pre></div><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p>
</blockquote>
<h5 id="c-如果-promise-状态已经被修改再抛出错误是无效的">c) 如果 Promise 状态已经被修改，再抛出错误是无效的</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功了&#39;</span><span class="p">);</span> <span class="c1">//换成 reject(&#39;成功了&#39;) 结果也是一样的
</span><span class="c1"></span><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;成功后扔抛出异常&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">promise</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> 
<span class="p">});</span>
<span class="c1">// 成功了
</span></code></pre></div><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过)</p>
</blockquote>
<h5 id="d-promise-对象的错误具有-冒泡-性质">d) Promise 对象的错误具有 “冒泡” 性质</h5>
<blockquote>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span> <span class="c1">//第一个promise
</span><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//第二个promise
</span><span class="c1"></span><span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//第三个promise
</span><span class="c1"></span><span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理前面三个Promise产生的错误
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>上面代码中，一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>也是因为这个特性,有了 <strong>异常穿透问题</strong></p>
</blockquote>
<h5 id="e-异常穿透问题">e) 异常穿透问题</h5>
<blockquote>
<ul>
<li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li>
<li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">),</span><span class="nx">e</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;被then的错误回调捕获&#39;</span><span class="p">,</span><span class="nx">e</span><span class="p">)</span> <span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//执行结果: 被then的错误回调捕获 Error: 抛出异常
</span><span class="c1"></span>
<span class="cm">/******************** 利用异常穿透 ****************************************/</span>
<span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//此处差异,不指定 reject 回调,利用异常穿透传到最后
</span><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//执行结果:  错误捕获:  Error: 抛出异常
</span></code></pre></div><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../image/Promise_study/image-20210927105504988.png" alt="image-20210927105504988"></p>
</blockquote>
<h5 id="f-建议使用-catch-进行异常处理">f) 建议使用 catch() 进行异常处理</h5>
<blockquote>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// bad
</span><span class="c1"></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
<span class="nx">data</span><span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">,</span><span class="nx">data</span><span class="p">),</span>
<span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">);</span>
<span class="cm">/********* 好的写法 ********************/</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="nx">data</span><span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">,</span><span class="nx">data</span><span class="p">))</span> <span class="c1">//只指定成功回调
</span><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span> <span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">));</span>
</code></pre></div><p>上面代码中，第二种写法要好于第一种写法:</p>
<ul>
<li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li>
<li>也更接近同步的写法（<code>try/catch</code>）</li>
<li>因此, 建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</li>
</ul>
</blockquote>
<h5 id="g-与传统-trycatch-代码块的差异">g) 与传统 <code>try/catch</code> 代码块的差异</h5>
<blockquote>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 下面一行会报错，因为hong 没有声明
</span><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
<span class="p">});</span>
<span class="p">};</span>
<span class="c1">//Promise 的 then() 处理,但不处理异常
</span><span class="c1"></span><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;只指定成功回调,不处理异常错误&#39;</span><span class="p">)</span> 
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">)</span> 
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="c1">// Uncaught (in promise) ReferenceError: hong is not defined
</span><span class="c1">// 努力学习的汪
</span></code></pre></div><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。</p>
<blockquote>
<ul>
<li>浏览器运行到这一行，会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li>
<li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li>
<li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="h-catch方法后还能跟-then-方法">h) catch()方法后还能跟 then() 方法</h5>
<blockquote>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 下面一行会报错，因为 hong 没有声明
</span><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
<span class="p">});</span>
<span class="p">};</span>

<span class="nx">someAsyncThing</span><span class="p">()</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>  
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捉到错误咯:&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获后我还要浪&#39;</span><span class="p">)</span> 
<span class="p">});</span>
<span class="c1">//捉到错误咯: ReferenceError: hong is not defined
</span><span class="c1">//错误捕获后我还要浪
</span></code></pre></div><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。</p>
<p>如果没有报错，则会跳过<code>catch()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;硬是成功了&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捉错误&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch后面的then: &#39;</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span> <span class="p">);</span>
<span class="c1">//catch后面的then:  硬是成功了
</span></code></pre></div><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
</blockquote>
<h5 id="i-catch方法之中还能再抛出错误">i) <code>catch()</code>方法之中，还能再抛出错误</h5>
<blockquote>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 下面一行会报错，因为 hong 没有声明
</span><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
<span class="p">});</span>
<span class="p">};</span>

<span class="nx">someAsyncThing</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span>  <span class="nx">someOtherAsyncThing</span><span class="p">())</span> 
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ctach:&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
  <span class="c1">// 下面一行会报错，因为 sum 没有声明
</span><span class="c1"></span>  <span class="nx">sum</span> <span class="o">++</span><span class="p">;</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕获后的then()&#39;</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">// ctach: [ReferenceError: hong is not defined]
</span><span class="c1">// Uncaught (in promise) ReferenceError: sum is not defined
</span></code></pre></div><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">someOtherAsyncThing</span><span class="p">();</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
  <span class="c1">// 下面一行会报错，因为 sum 没有声明
</span><span class="c1"></span><span class="nx">sum</span> <span class="o">++</span><span class="p">;</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch()后的catch: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">//catch:  ReferenceError: hong is not defined
</span><span class="c1">//catch()后的catch:  ReferenceError: sum is not defined
</span></code></pre></div><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
</blockquote>
<h4 id="-promiseprototypefinally">③ Promise.prototype.finally()</h4>
<blockquote>
<p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">})</span>
<span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">});</span>
</code></pre></div><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<blockquote>
<ul>
<li><code>finally</code>方法的回调函数不接受任何参数，</li>
<li>这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li>
<li>这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="a-finally本质上是then方法的特例">a) <code>finally</code>本质上是<code>then</code>方法的特例</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">promise</span>
<span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>

<span class="c1">// 等同于
</span><span class="c1"></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
<span class="nx">result</span> <span class="p">=&gt;</span>  <span class="nx">result</span> <span class="p">,</span>
<span class="nx">error</span> <span class="p">=&gt;</span>  <span class="k">throw</span> <span class="nx">error</span>
<span class="p">);</span>
</code></pre></div><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
</blockquote>
<h5 id="b-它的实现">b) 它的实现</h5>
<blockquote>
<p>它的实现也很简单。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">P</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
  <span class="nx">value</span>  <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">),</span>
  <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span> <span class="p">})</span>
<span class="p">);</span>
<span class="p">};</span>
</code></pre></div><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// resolve 的值是 undefined
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{})</span>

<span class="c1">// resolve 的值是 2
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{})</span>

<span class="c1">// reject 的值是 undefined
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{})</span>

<span class="c1">// reject 的值是 3
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
</code></pre></div><p><img src="../image/Promise_study/image-20210927135255264.png" alt="image-20210927135255264"></p>
</blockquote>
<h4 id="-promiseall">④ Promise.all()</h4>
<blockquote>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</code></pre></div><blockquote>
<ul>
<li><code>Promise.all()</code>方法接受一个数组作为参数，</li>
<li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</li>
<li>另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="a-返回的状态由什么决定">a) 返回的状态由什么决定?</h5>
<blockquote>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<blockquote>
<ol>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li>
</ol>
</blockquote>
<h6 id="下面是一个具体的例子">下面是一个具体的例子。</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 生成一个Promise对象的数组
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;hong&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span> <span class="nx">item</span><span class="o">+</span><span class="s1">&#39;.json&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>，或者<strong>其中有一个变为<code>rejected</code></strong>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<h6 id="下面是另一个例子">下面是另一个例子</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">databasePromise</span> <span class="o">=</span> <span class="nx">connectDatabase</span><span class="p">();</span> <span class="c1">//假设定义了一个异步方法,此方法能拿到你需要的所有数据
</span><span class="c1"></span>
<span class="kr">const</span> <span class="nx">booksPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>     <span class="c1">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息
</span><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">findAllBooks</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">userPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>    <span class="c1">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息
</span><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">getCurrentUser</span><span class="p">);</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
<span class="nx">booksPromise</span><span class="p">,</span>
<span class="nx">userPromise</span>
<span class="p">])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">pickTopRecommendations</span><span class="p">(</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">));</span>
</code></pre></div><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
</blockquote>
<h5 id="b-如果参数中的promise实例定义了自己的catch方法-">b) 如果参数中的Promise实例定义了自己的catch方法 ?</h5>
<blockquote>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//定义一个状态将为成功的的promise
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span><span class="p">);</span>

<span class="c1">//定义一个将抛出错误的promise
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2自己的catch捕获: &#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="k">return</span> <span class="nx">e</span><span class="p">;</span> <span class="c1">//异常获取后原样返回,不做修改
</span><span class="c1"></span><span class="p">});</span>

<span class="c1">//调用 Promise.all 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39; Promise.all 方法中的成功回调: &#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34; Promise.all 方法中的catch&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">));</span>

<span class="c1">//p2自己的catch捕获:  Error: 报错了
</span><span class="c1">// Promise.all 方法中的成功回调:  (2) [&#39;hello&#39;, Error: 报错了]
</span></code></pre></div><p>上面代码中，</p>
<blockquote>
<ul>
<li><code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code></li>
<li>但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。</li>
<li>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li>
<li>因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数</li>
</ul>
</blockquote>
</blockquote>
<h5 id="c--如果参数中的promise实例-没有-定义自己的catch方法-">c)  如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?</h5>
<blockquote>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//定义一个状态将为成功的的promise
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>

<span class="c1">//定义一个将抛出错误的promise
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">)</span> 
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>

<span class="c1">//调用 Promise.all 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39; Promise.all 方法中的成功回调: &#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34; Promise.all 方法中的catch&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">));</span>

<span class="c1">// Promise.all 方法中的catch Error: 报错了
</span></code></pre></div></blockquote>
<h4 id="-promiserace">⑤ Promise.race()</h4>
<blockquote>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</code></pre></div><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
</blockquote>
<h5 id="a-举个简单的">a) 举个简单的🌰</h5>
<blockquote>
<p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">})</span>
<span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
<span class="c1">//调用
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></blockquote>
<h5 id="b-举个应用实">b) 举个应用实🌰</h5>
<blockquote>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">),</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;请求超时!!!!&#39;</span><span class="p">)),</span> <span class="mi">5000</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">]);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span>
</code></pre></div><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<p>是不是很好用又简单</p>
</blockquote>
<h4 id="-promiseallsettled">⑥ Promise.allSettled()</h4>
<blockquote>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p>
<p><strong>只有等到所有这些参数实例都返回结果</strong>，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p>
<p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p>
</blockquote>
<h5 id="a-举个简单的-1">a) 举个简单的🌰</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">),</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">),</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">),</span>
<span class="p">];</span>
<span class="nx">loading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层
</span><span class="c1"></span><span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
<span class="nx">loading</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></div><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
</blockquote>
<h5 id="b--该方法返回的新的-promise-实例一旦结束状态总是fulfilled不会变成rejected">b)  该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code></h5>
<blockquote>
<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;返回成功状态的promise&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;返回失败状态的promise&#39;</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">allSettledPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">]);</span>
<span class="c1">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`
</span><span class="c1"></span><span class="nx">allSettledPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span> 
<span class="c1">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里
</span><span class="c1"></span><span class="p">});</span>
<span class="cm">/*
</span><span class="cm">[
</span><span class="cm">  { &#34;status&#34;: &#34;fulfilled&#34;, &#34;value&#34;: &#34;返回成功状态的promise&#34; },
</span><span class="cm">  { &#34;status&#34;: &#34;rejected&#34;, &#34;reason&#34;: &#34;返回失败状态的promise&#34; }
</span><span class="cm">]
</span><span class="cm">*/</span>
</code></pre></div><blockquote>
<ul>
<li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li>
<li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li>
<li>每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li>
<li><code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="c-举个返回值用法的">c) 举个返回值用法的🌰</h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">),</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">)</span> <span class="p">];</span>
<span class="kr">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>

<span class="c1">// 过滤出成功的请求
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">successfulPromises</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">);</span>

<span class="c1">// 过滤出失败的请求，并取得它们的失败原因
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">errors</span> <span class="o">=</span> <span class="nx">results</span>
<span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</code></pre></div><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">urls</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;https://gitee.com/hongjilin&#39;</span> <span class="p">,</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">requests</span> <span class="o">=</span> <span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
<span class="c1">//举例用 Promise.all 尝试实现,很明显,难以实现
</span><span class="c1"></span><span class="k">try</span> <span class="p">{</span>
<span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">requests</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;所有请求都成功。&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;至少一个请求失败，其他请求可能还没结束。&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了</p>
</blockquote>
<h4 id="-promiseany">⑦ Promise.any()</h4>
<blockquote>
<p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
</blockquote>
<h5 id="a-与-promiserace-方法的区别">a) 与 <code>Promise.race()</code> 方法的区别</h5>
<blockquote>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span>
<span class="p">];</span>

<span class="k">try</span> <span class="p">{</span>
<span class="kr">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
</blockquote>
<h5 id="b-promiseany-抛出的错误">b) Promise.any() 抛出的错误</h5>
<blockquote>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nx">AggregateError</span><span class="p">()</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="o">-&gt;</span> <span class="nx">AggregateError</span>

<span class="kr">const</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AggregateError</span><span class="p">();</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;first error&#34;</span><span class="p">));</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;second error&#34;</span><span class="p">));</span>
<span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</code></pre></div><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
<span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// Any of the promises was fulfilled.
</span><span class="c1"></span><span class="p">},(</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// All of the promises were rejected.
</span><span class="c1"></span><span class="p">}</span>
<span class="p">);</span>
</code></pre></div></blockquote>
<h5 id="c-再举个">c) 再举个🌰</h5>
<blockquote>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">alsoRejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;太失败了&#39;</span><span class="p">);</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">([</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">,</span> <span class="nx">alsoRejected</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// 成功
</span><span class="c1"></span><span class="p">});</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">([</span><span class="nx">rejected</span><span class="p">,</span> <span class="nx">alsoRejected</span><span class="p">]).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>  <span class="c1">//AggregateError: All promises were rejected
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p>
</blockquote>
<h4 id="-promiseresolve">⑧ Promise.resolve()</h4>
<blockquote>
<p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">jsPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">));</span>
</code></pre></div><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">)</span>
<span class="c1">// 等价于
</span><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">))</span>
</code></pre></div><p><code>Promise.resolve()</code>方法的参数分成四种情况</p>
</blockquote>
<h5 id="a-参数是一个-promise-实例">a) 参数是一个 Promise 实例</h5>
<blockquote>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
</blockquote>
<h5 id="b-参数是一个thenable对象"><strong>b) 参数是一个<code>thenable</code>对象</strong></h5>
<blockquote>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  	<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>  <span class="c1">// &#39;成功&#39;
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出 <strong>&lsquo;成功&rsquo;</strong>。</p>
</blockquote>
<h5 id="c-参数不是具有then方法的对象或根本就不是对象">c) 参数不是具有<code>then()</code>方法的对象，或根本就不是对象</h5>
<blockquote>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">});</span>
<span class="c1">// 努力学习的汪
</span></code></pre></div><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p>
<blockquote>
<ul>
<li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li>
<li>返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行</li>
<li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li>
</ul>
</blockquote>
</blockquote>
<h5 id="d-不带有任何参数">d) 不带有任何参数</h5>
<blockquote>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{});</span>
</code></pre></div><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 &ndash;&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8Bevent-loop%E6%9C%BA%E5%88%B6">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">);</span> <span class="c1">//这里是新的一轮事件循环
</span><span class="c1"></span><span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">);</span> <span class="c1">//本轮同步代码结束后,新一轮事件循环前,就执行
</span><span class="c1"></span><span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">);</span>

<span class="c1">// one
</span><span class="c1">// two
</span><span class="c1">// three
</span></code></pre></div><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log('one')</code>则是立即执行，因此最先输出。</p>
</blockquote>
<h4 id="-promisereject">⑨ Promise.reject()</h4>
<blockquote>
<p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
<span class="c1">// 等同于
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">))</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">});</span>
<span class="c1">// 出错了
</span></code></pre></div><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span> <span class="o">===</span> <span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// true
</span></code></pre></div><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
</blockquote>
<h4 id="-promisetry">⑩ Promise.try()</h4>
<blockquote>
<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
<span class="c1">// next
</span><span class="c1">// now
</span></code></pre></div><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<h6 id="那么有没有一种方法让同步函数同步执行异步函数异步执行并且让它们具有统一的-api-呢">那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</h6>
</blockquote>
<h5 id="a-写法一--用async函数来写">a) 写法一 : 用<code>async</code>函数来写</h5>
<blockquote>
<p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
<span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
<span class="c1">// now
</span><span class="c1">// next
</span></code></pre></div><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</code></pre></div><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</code></pre></div></blockquote>
<h5 id="b--写法二--使用new-promise">b)  写法二 : 使用<code>new Promise()</code></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
<span class="p">(</span>
<span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
  <span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span>
<span class="p">)</span>
<span class="p">)();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
<span class="c1">// now
</span><span class="c1">// next
</span></code></pre></div><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
</blockquote>
<h5 id="c-promisetry的引出">c) Promise.try的引出</h5>
<blockquote>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
<span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
<span class="c1">// now
</span><span class="c1">// next
</span></code></pre></div><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getUsername</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">});</span>
<span class="p">}</span>
</code></pre></div><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</code></pre></div><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">try</span> <span class="p">{</span>
<span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">}))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</code></pre></div><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
</blockquote>
<hr>
<h1 id="三自定义promise手写">三、自定义Promise手写</h1>
<blockquote>
<ol>
<li>下方的<code>Promise.prototype.then</code>与<code>Promise.resolve</code>为什么一个挂载在<code>prototype</code>而另一个挂载在实例对象上?</li>
</ol>
<p>解:原因是分别为静态方法与实例方法</p>
<p>&ndash;&gt;上面的需要new实例化的时候自动继承实例<code>prototype</code>上的方法和属性,所以用<code>实例对象.then()</code>来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用</p>
<h2 id="此部分可以跳过不看类似手撕源码"><strong>此部分可以跳过不看,类似手撕源码</strong></h2>
</blockquote>
<h2 id="-promise的实例方法实现">Ⅰ-Promise的实例方法实现</h2>
<h3 id="1---初始结构搭建">1 - 初始结构搭建</h3>
<blockquote>
<p>html引入,该章节后续html大部分重复 除非必要,否则不再放上来</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Promise-封装 | 1 - 初始结构搭建<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./promise.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
        <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">},</span> <span class="nx">reason</span><span class="p">=&gt;{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><blockquote>
<p>promise.js  &ndash;&gt;使用原生写法,最后会改为class写法</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){}</span>
<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){}</span>
</code></pre></div><h3 id="2---resolve-与-reject构建与基础实现">2 - resolve 与 reject构建与基础实现</h3>
<blockquote>
<ol>
<li>使用<code>const self = this;</code>保存this执行,使function中可以取得当前实例</li>
</ol>
<p>ps:可以不使用该方法保存,但是下方function需要<code>改为箭头函数</code>,否则<code>function默认指向是window</code></p>
<p>之后代码默认使用<code>self</code>保存this,箭头函数方式将在最后改为class写法时使用</p>
<ol start="2">
<li>默认设置 <code>PromiseState = 'pending'以及 PromiseResult = null</code>,这就是promise状态基础</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">//声明构造函数
</span><span class="c1"></span><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//添加属性
</span><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">//保存实例对象的 this 的值
</span><span class="c1"></span><span class="cm">/*  此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */</span>
  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> 
  <span class="c1">//resolve 函数
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span><span class="o">--------------------------------------------</span>
    <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="c1">// resolved
</span><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//reject 函数
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span><span class="o">----------------------------------------------</span>
    <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="c1">// 
</span><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//同步调用『执行器函数』
</span><span class="c1"></span>  <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div><h3 id="3---throw-抛出异常改变状态">3 - throw 抛出异常改变状态</h3>
<blockquote>
<ol>
<li>在2的基础上进行修改:将执行器放入<code>try-catch()</code>中</li>
<li>在catch中使用<code>reject()</code>修改 promise 对象状态为『<code>失败</code>』</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"> <span class="k">try</span> <span class="p">{</span>
    <span class="c1">//同步调用『执行器函数』
</span><span class="c1"></span>    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//修改 promise 对象状态为『失败』
</span><span class="c1"></span>    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div><h3 id="4---状态只能修改一次">4 - 状态只能修改一次</h3>
<blockquote>
<ol>
<li>
<p>基于2 3代码中resolve和reject方法进修改</p>
</li>
<li>
<p>在成功与失败函数中添加判断<code> if(self.PromiseState !== 'pending') return;</code>,如果进入函数时状态不为<code>pending</code>直接退出,这样就能做到状态只能从<code>pending</code>改至其他状态且做到只能改一次</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">--------------------------------------------------------</span>
 <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
      <span class="c1">//抛出异常
</span><span class="c1"></span>      <span class="c1">// throw &#34;error&#34;;
</span><span class="c1"></span>    <span class="p">});</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改</span><span class="o">--------------------------------------------------------</span>

  <span class="c1">//resolve 函数
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="c1">//判断状态
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span><span class="c1">// resolved
</span><span class="c1"></span>        <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//reject 函数
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="c1">//判断状态
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span><span class="c1">// 
</span><span class="c1"></span>        <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><h3 id="5---then-方法执行回调基础实现">5 - then 方法执行回调基础实现</h3>
<blockquote>
<ol>
<li>修改<code>Promise.prototype.then</code>方法</li>
<li>传入<code>then(成功回调,失败回调)</code>,当调用then后,会判断当前<code>this.PromiseState</code>的状态,当其为成功时调用<code>成功回调</code>,失败时调用<code>失败回调</code></li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// resolve(&#39;OK&#39;);// reject(&#34;Error&#34;);
</span><span class="c1"></span>      <span class="k">throw</span> <span class="s2">&#34;ERROR&#34;</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
        <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">},</span> 
        <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);}</span>
    <span class="p">)</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
<span class="p">}</span>
</code></pre></div><h3 id="6---异步任务-then-方法实现">6 - 异步任务 then 方法实现</h3>
<blockquote>
<ol>
<li>
<p>此处对于5有四处修改,下面上<code>js代码</code></p>
</li>
<li>
<p>当我运行<code>异步代码</code>后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的<code>p</code>为<code>pending</code>状态,所以根本不会执行resolve与reject方法</p>
</li>
</ol>
<p>解:添加判断<code>pending</code>状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到</p>
<ol start="3">
<li>为什么要将回调保存到实例上而不是直接调用?</li>
</ol>
<p><code>理由</code>:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数
所以当你调用<code>then()</code>时却检测到状态为<code>pending</code>,说明这时候的promise在异步队列 不能直接运行成功或者失败函数</p>
<p><code>解决</code>:因为<code>resolve与reject</code>方法与<code>then()</code>不在同一个作用域中,并不能共享<code>then(成功回调,失败回调)</code>的参数,所以在判断状态为<code>pending</code>时将回调保存到实例对象上.然后将回调函数的调用放在<code>resolve()与reject()</code>中</p>
<p>这样当我代码运行到异步队列的<code>resolve()或reject()</code>时,就可以在这个函数中运行回调函数,实现异步then</p>
<ol start="4">
<li>此处的then<code>仍有瑕疵</code>,需要继续完善</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
 <span class="c1">//实例化对象
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span> <span class="cm">/* resolve(&#39;OK&#39;);*/</span><span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//声明构造函数
</span><span class="c1"></span><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// 声明属性     
</span><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="p">{};</span>			<span class="o">-----------</span><span class="nx">新添加1</span>
  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> 
    
  <span class="c1">//resolve 函数
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//判断状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="c1">//调用成功的回调函数  加判断的原因是防止无回调报错
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">}</span>  <span class="o">------------</span><span class="nx">新添加2</span> <span class="nx">最重要</span> 
  <span class="p">}</span>
    
  <span class="c1">//reject 函数
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="c1">//执行回调						
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);}</span>  <span class="o">------------</span><span class="nx">新添加3</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span><span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);}</span>
<span class="p">}</span>

<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
  <span class="c1">//判断 pending 状态
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>  <span class="o">------------</span><span class="nx">新添加4</span>
    <span class="c1">//保存回调函数
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
      <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="7---指定多个回调">7 - 指定多个回调</h3>
<blockquote>
<ol>
<li>
<p>基于6代码进行修改 只展示修改部分代码</p>
</li>
<li>
<p><code>6</code>中保存回调函数的方式有BUG,如果我有多个<code>.then()</code>,后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数<code>有且只有</code>最后一个</p>
</li>
</ol>
<p>解:使用<code>数组</code>的方式进行存储回调函数,调用时也是用数组循环取出</p>
<ol start="3">
<li>此处的then<code>仍有瑕疵</code>,需要继续完善</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
<span class="c1">//实例化对象
</span><span class="c1"></span>   <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;No&#39;</span><span class="p">);},</span> <span class="mi">1000</span><span class="p">);});</span>
   <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span> <span class="nx">reason</span><span class="p">=&gt;{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
   <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span> <span class="nx">reason</span><span class="p">=&gt;{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">//resolve 函数
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  		<span class="p">.....</span>
        <span class="c1">//调用成功的回调函数
</span><span class="c1"></span>        <span class="c1">// if (self.callback.onResolved) { self.callback.onResolved(data); } 
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>   <span class="o">--------</span><span class="nx">修改1</span>
            <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">//reject 函数
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
     	 <span class="p">......</span>
        <span class="c1">//执行失败的回调
</span><span class="c1"></span>        <span class="c1">// if (self.callback.onResolved) { self.callback.onResolved(data);}
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>		<span class="o">------</span><span class="nx">修改2</span>
            <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
    
  <span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
    <span class="p">........</span>
    <span class="c1">//判断 pending 状态
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
        <span class="c1">//保存回调函数
</span><span class="c1"></span>        <span class="c1">//  this.callback = { onResolved: onResolved, onRejected: onRejected }
</span><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>					<span class="o">--------</span><span class="nx">修改3</span>
            <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
            <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="8---同步任务-then-返回结果">8 - 同步任务 then 返回结果</h3>
<blockquote>
<ol>
<li>在之前的then运行结果中得知,我们使用  [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象</li>
</ol>
<p>解:所以我们在then中<code>return new Promise()</code>,使其得到的是一个新的promise对象</p>
<ol start="2">
<li>在为<code>解决问题1</code>后产生一个新问题:新的promise对象因为没有用<code>rejerect与resolve</code>方法,导致返回的状态一直是<code>pending</code></li>
</ol>
<p>解:在新的promise中判断<code>运行回调函数</code>后的返回值是什么,然后根据其不同类型给其赋予不同状态</p>
<p>​	Ⅰ-<code>if(result instanceof Promise)</code>:返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称<code>②promise对象</code>),在返回值(因为是promise对象)的<code>.then()</code>回调函数中使用rejerect与resolve方法,将其<code>自身的状态</code>赋予外层的promise,</p>
<p>​	即 回调函数中的promise 赋值 给then返回值 ,  所以 <code>最终返回状态==回调函数中的新promise状态</code></p>
<p>​	Ⅱ-如果返回值是一个<code>非promise</code>对象,返回状态设置为成功</p>
<p>​	Ⅲ-如果返回值是一个异常,返回状态设置为失败</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
  <span class="c1">//实例化对象
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);});</span>
    <span class="c1">//执行 then 方法
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
     <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="s2">&#34;FAIL&#34;</span><span class="p">;},</span>
    <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span> <span class="c1">//  if(this.PromiseState === &#39;fulfilled&#39;){ onResolved(this.PromiseResult);} 未修改时代码
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">){</span>    <span class="o">-------</span><span class="nx">修改1</span> 
            <span class="k">try</span><span class="p">{</span>
                <span class="c1">//获取回调函数的执行结果
</span><span class="c1"></span>                <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
                <span class="c1">//判断
</span><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">){</span><span class="c1">//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层
</span><span class="c1"></span>                    <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>  <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="p">},</span><span class="nx">r</span><span class="p">=&gt;{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);})</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>  <span class="c1">//如果返回的不是promise对象,都将其赋予成功状态
</span><span class="c1"></span>            <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                <span class="nx">rejerect</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>	<span class="c1">//如果出错了,则返回失败状态
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">){</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span><span class="o">------</span><span class="nx">此部分修改与修改1一样</span>
        <span class="c1">//判断 pending 状态
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span><span class="p">});</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h3 id="9---异步任务-then-返回结果">9 - 异步任务 then 返回结果</h3>
<blockquote>
<ol>
<li>
<p>异步任务是修改<code>if(this.PromiseState === 'pending')</code>后面的值,原因参考<code>6</code>,下面代码只举例这部分修改</p>
</li>
<li>
<p>因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行<code>加工</code>,<code>添加判断其回调函数的返回值</code>的代码块再存入实例的回调函数中</p>
</li>
</ol>
<p>Ⅰ-声明一个新的函数:其内部功能-&gt;先运行<code>onResolved回调函数</code>,再将其返回值取出,进行判断其返回值(这个过程同<code>8</code>)</p>
<p>Ⅱ-加工后存入实例回调函数数组,之后在<code>resolve与reject</code>方法中调用即可(同<code>6</code>)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
   <span class="c1">//实例化对象
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;Error&#34;</span><span class="p">);},</span> <span class="mi">1000</span><span class="p">)});</span> <span class="c1">// resolve(&#39;OK&#39;);
</span><span class="c1"></span>    <span class="c1">//执行 then 方法
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// return &#39;oh Yeah&#39;;  //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误
</span><span class="c1"></span>      <span class="k">throw</span> <span class="s1">&#39;error&#39;</span><span class="p">;</span>
    <span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="s2">&#34;xx&#34;</span><span class="p">);</span> <span class="c1">//如果只是打印没返回,则实际上时返回一个undefined,
</span><span class="c1"></span>      <span class="c1">//在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined
</span><span class="c1"></span>      <span class="k">return</span> <span class="s2">&#34;sss&#34;</span>   <span class="c1">// throw &#39;error&#39;;
</span><span class="c1"></span>    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
    <span class="c1">//判断 pending 状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//保存回调函数
</span><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          
        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">try</span> <span class="p">{</span>
            <span class="c1">//执行成功回调函数
</span><span class="c1"></span>            <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onResolved</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
            <span class="c1">//判断 其结果
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
                  <span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);},</span>
                  <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
                 <span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>
          <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);}</span>
        <span class="p">},</span>
          
        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">try</span> <span class="p">{</span>
            <span class="c1">//执行成功回调函数
</span><span class="c1"></span>            <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
            <span class="c1">//判断
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
                  <span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="p">},</span>
                  <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
                 <span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>
          <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
</code></pre></div><h3 id="10--then方法代码优化">10- then方法代码优化</h3>
<blockquote>
<ol>
<li>在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">封装函数</span><span class="o">----------------------------------------------------------------------------</span>
    <span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="c1">//获取回调函数的执行结果
</span><span class="c1"></span>        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">type</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
        <span class="c1">//判断
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//如果是 Promise 类型的对象
</span><span class="c1"></span>          <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
          <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
          <span class="p">})</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">//结果的对象状态为『成功』
</span><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="o">-----------------------------------------------------------------------------------</span>    
    <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//判断 pending 状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//保存回调函数
</span><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h3 id="11---catch-方法与异常穿透与值传递">11 - catch 方法与异常穿透与值传递</h3>
<blockquote>
<ol>
<li>
<p>异常穿透:添加<code>catch 方法 </code>,并且需要进行回调函数为<code>undefined的</code>处理</p>
</li>
<li>
<p>当我<code>then()</code>中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是<code>undefined</code></p>
</li>
</ol>
<p>解:进行回调函数判断,当其为空时,基于默认回调函数内容:<code>直接往外抛出</code>这样下方的<code>then() or catch()</code>就可以承接到异常或者值</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
<span class="c1">//实例化对象
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="c1">//值传递
</span><span class="c1"></span>    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">()</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);})</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>				<span class="o">-----------</span><span class="nx">修改1</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onRejected</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onRejected</span> <span class="o">=</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span><span class="p">;}}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onResolved</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="nx">onResolved</span> <span class="o">=</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">;}</span>
	 <span class="p">....</span>
<span class="p">}</span>
<span class="c1">//添加 catch 方法  
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">catch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">){</span>  <span class="o">---------------</span><span class="nx">异常穿透</span> <span class="nx">修改2</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="-promise的静态方法实现">Ⅱ-Promise的静态方法实现</h2>
<h3 id="1---promiseresolve-封装">1 - Promise.resolve 封装</h3>
<blockquote>
<ol>
<li>
<p>判断传入的参数是否为<code>promise对象</code>:</p>
<p>Ⅰ-如果为<code>promise</code>:将其状态与结果赋值给外层promise对象</p>
<p>Ⅱ-如果为<code>非promise</code>:状态设置为成功</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
 <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
 <span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>     
      <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span><span class="c1">// resolve(&#39;Success&#39;);
</span><span class="c1"></span>    <span class="p">}));</span>
 <span class="kr">const</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">));</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p3</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 resolve 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
    <span class="c1">//返回promise对象
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">){</span>
            <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
                <span class="nx">v</span><span class="p">=&gt;{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);},</span>
                <span class="nx">r</span><span class="p">=&gt;{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
            <span class="p">)}</span><span class="k">else</span><span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">}</span><span class="c1">//状态设置为成功
</span><span class="c1"></span>    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div><h3 id="2---promiseresolve-封装">2 - Promise.resolve 封装</h3>
<blockquote>
<p>不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为<code>失败</code>即可</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
   <span class="c1">//Promise.reject
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
    <span class="p">}));</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 reject 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div><h3 id="3---promiseall-封装">3 - Promise.all 封装</h3>
<blockquote>
<ol>
<li>遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回<code>成功</code>状态</li>
<li>如果当数组中任意一个promise的执行结果是<code>reject</code>,直接中断,返回状态为<code>失败</code></li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
<span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
    <span class="c1">//调用 all 方法
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 all 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//返回结果为promise对象
</span><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">//声明变量
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">//遍历
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//得知对象的状态是成功
</span><span class="c1"></span>        <span class="c1">//每个promise对象 都成功
</span><span class="c1"></span>        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">//将当前promise对象成功的结果 存入到数组中
</span><span class="c1"></span>        <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="c1">//判断
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);}</span><span class="c1">//修改状态
</span><span class="c1"></span>      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div><h3 id="4---promiserace-封装">4 - Promise.race 封装</h3>
<blockquote>
<p>直接谁先执行就返回谁的运行结果即可</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
 <span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);});</span>
    <span class="p">});</span>
    <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
    <span class="c1">//调用 race 方法
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
<span class="c1">//添加 race 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//修改返回对象的状态为 『成功』
</span><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//修改返回对象的状态为 『失败』
</span><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div><h2 id="-其他优化">Ⅲ-其他优化</h2>
<h3 id="1---回调函数异步执行">1 - 回调函数『异步执行』</h3>
<blockquote>
<ol>
<li>如果我们运行下面代码,正确顺序是: 111 &ndash;&gt; 333 &ndash;&gt;444</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">111</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);</span>
  <span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">444</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);</span>
</code></pre></div><ol start="2">
<li>但当我们运行之前封装的 <strong>Promise</strong> 代码时,结果却是:111 &ndash;&gt; 444 &ndash;&gt; 333</li>
</ol>
<p>我们需要将我们的then方法变成<code>异步方法</code></p>
<ol start="3">
<li>我们只要在以下四处地方的<code>回调函数调用</code>外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">});</span> <span class="p">});</span><span class="o">--</span><span class="nx">修改1</span>
  <span class="p">}</span>
 <span class="c1">//reject 函数
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">});</span> <span class="p">});</span><span class="o">---</span><span class="nx">修改2</span>
  <span class="p">}</span>

<span class="c1">//添加 then 方法
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span>     <span class="cm">/*  修改前代码
</span><span class="cm">     if (this.PromiseState === &#39;fulfilled&#39;) { callback(onResolved); }
</span><span class="cm"> 		if (this.PromiseState === &#39;rejected&#39;) { callback(onRejected);
</span><span class="cm"> 		 */</span>
      <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">){</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);});}</span>  <span class="o">-----</span><span class="nx">修改3</span>
      <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">){</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);});</span>   <span class="o">---</span><span class="nx">修改4</span>
      <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div><ol start="4">
<li><code>相关原理参照js事件循环机制、宏任务与微任务</code></li>
</ol>
</blockquote>
<h3 id="2--class改写promise">2- class改写promise</h3>
<blockquote>
<ol>
<li>其中将<code>self=this</code>保存this指向方式改为箭头函数表示(在上面示例中也有效果)</li>
<li>将其改为class写法</li>
<li>下面为promisedemo.js代码</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nb">Promise</span> <span class="p">{</span>
<span class="c1">//构造方法
</span><span class="c1"></span><span class="nx">constructor</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//添加属性
</span><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">//声明属性
</span><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//保存实例对象的 this 的值
</span><span class="c1"></span>  <span class="c1">//resolve 函数
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">//判断状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="c1">// resolved
</span><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="c1">//调用成功的回调函数
</span><span class="c1"></span>    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">//reject 函数
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">reject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">//判断状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">//1. 修改对象的状态 (promiseState)
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="c1">// 
</span><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="c1">//执行失败的回调
</span><span class="c1"></span>    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">//同步调用『执行器函数』
</span><span class="c1"></span>    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//修改 promise 对象状态为『失败』
</span><span class="c1"></span>    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//then 方法封装
</span><span class="c1"></span><span class="nx">then</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//判断回调函数参数
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onRejected</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">onRejected</span> <span class="o">=</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="nx">reason</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onResolved</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">onResolved</span> <span class="o">=</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">;</span>
    <span class="c1">//value =&gt; { return value};
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">//封装函数
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">callback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="c1">//获取回调函数的执行结果
</span><span class="c1"></span>        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">type</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
        <span class="c1">//判断
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//如果是 Promise 类型的对象
</span><span class="c1"></span>          <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
          <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
          <span class="p">})</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">//结果的对象状态为『成功』
</span><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//调用回调函数  PromiseState
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">//判断 pending 状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//保存回调函数
</span><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//catch 方法
</span><span class="c1"></span><span class="k">catch</span> <span class="p">(</span><span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//添加 resolve 方法
</span><span class="c1"></span><span class="kr">static</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//返回promise对象
</span><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
      <span class="p">})</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//状态设置为成功
</span><span class="c1"></span>      <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">//添加 reject 方法
</span><span class="c1"></span><span class="kr">static</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">//添加 all 方法
</span><span class="c1"></span><span class="kr">static</span> <span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//返回结果为promise对象
</span><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">//声明变量
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">//遍历
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//
</span><span class="c1"></span>      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//得知对象的状态是成功
</span><span class="c1"></span>        <span class="c1">//每个promise对象 都成功
</span><span class="c1"></span>        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">//将当前promise对象成功的结果 存入到数组中
</span><span class="c1"></span>        <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="c1">//判断
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//修改状态
</span><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">//添加 race 方法
</span><span class="c1"></span><span class="kr">static</span> <span class="nx">race</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//修改返回对象的状态为 『成功』
</span><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//修改返回对象的状态为 『失败』
</span><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></blockquote>
<blockquote>
<p>html文件调用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>class版本封装<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./promisedemo.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// resolve(&#34;OK&#34;);
</span><span class="c1"></span>  <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;Erosssr&#34;</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">});</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">));</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>

<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div></blockquote>
<h1 id="三promise-async--await">三、Promise+ async + await</h1>
<blockquote>
<h5 id="1promise异步">1)Promise==&gt;异步</h5>
<h5 id="2await异步转同步">2)await==&gt;异步转同步</h5>
<ol>
<li>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</li>
<li>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行</li>
</ol>
<h5 id="3async同步转异步">3)async==&gt;同步转异步</h5>
<ol>
<li>方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</li>
</ol>
<h6 id="4mdn文档">4)mdn文档</h6>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li>
</ol>
</blockquote>
<h2 id="-async函数">Ⅰ-async函数</h2>
<blockquote>
<ol>
<li>
<p>函数的返回值为 promise 对象</p>
</li>
<li>
<p>promise 对象的结果由 async 函数执行的返回值决定</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="c1">//1. 如果返回值是一个非Promise类型的数据
</span><span class="c1"></span>    <span class="c1">// return 521;
</span><span class="c1"></span>
    <span class="c1">//2. 如果返回的是一个Promise对象
</span><span class="c1"></span>    <span class="c1">// return new Promise((resolve, reject) =&gt; {
</span><span class="c1"></span>    <span class="c1">//     // resolve(&#39;OK&#39;);
</span><span class="c1"></span>    <span class="c1">//     reject(&#39;Error&#39;);
</span><span class="c1"></span>    <span class="c1">// });
</span><span class="c1"></span>
    <span class="c1">//3. 抛出异常
</span><span class="c1"></span>    <span class="c1">// throw &#34;Oh NO&#34;;
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">main</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></blockquote>
<h2 id="-await表达式">Ⅱ-await表达式</h2>
<blockquote>
<ol>
<li>
<p>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</p>
</li>
<li>
<p>如果表达式是 promise 对象, await 返回的是 promise 成功的值</p>
</li>
<li>
<p>如果表达式是其它值, 直接将此值作为 await 的返回值</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">// resolve(&#39;OK&#39;);
</span><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="c1">//1. 右侧为promise的情况
</span><span class="c1"></span>    <span class="c1">// let res = await p;
</span><span class="c1"></span>
    <span class="c1">//2. 右侧为其他类型的数据
</span><span class="c1"></span>    <span class="c1">// let res2 = await 20;
</span><span class="c1"></span>
    <span class="c1">//3. 如果promise是失败的状态
</span><span class="c1"></span>    <span class="k">try</span><span class="p">{</span>
        <span class="kd">let</span> <span class="nx">res3</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">p</span><span class="p">;</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">();</span>
</code></pre></div></blockquote>
<h2 id="-注意">Ⅲ-注意</h2>
<blockquote>
<ol>
<li>await 必须写在 async 函数中, 但 async 函数中可以没有 await</li>
<li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try&hellip;catch 捕获处理</li>
</ol>
</blockquote>
<h2 id="-自己对某些问题理解解答">Ⅳ-自己对某些问题理解解答</h2>
<h3 id="1如何在promise外部使用promise的结果">1、如何在Promise外部使用Promise的结果</h3>
<blockquote>
<p>用到的本章节知识:</p>
<p>1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将<code>new Promise(resolve =&gt; {setTimeout(function() { resolve(&quot;promise普通结果&quot;); }, 1000); })</code>等价于<code>axios({})</code></p>
<p>2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次</p>
<p>3、 上一步抛出后可以在下面 的.then()中获取到</p>
<p>Ⅰ-如果没有用.then(),则值会抛往Promise外部</p>
<p>Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出&ndash;<code>某些业务场景需要</code> ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) &mdash;前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">//讲解时写的简单demo
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">resolveCommon</span> <span class="o">=</span> <span class="p">()=&gt;</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">result</span><span class="o">=</span><span class="s2">&#34;普通promise初始值&#34;</span>
<span class="nx">result</span><span class="o">=</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;promise普通结果&#34;</span><span class="p">);</span> 
<span class="p">},</span> <span class="mi">1000</span><span class="p">);})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="c1">//打印结果: Promise { &lt;pending&gt; } 
</span><span class="c1"></span><span class="p">};</span>

<span class="kd">let</span> <span class="nx">resolveAsync</span><span class="o">=</span><span class="kr">async</span> <span class="p">()=&gt;</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">result</span><span class="o">=</span><span class="s2">&#34;await+async的promise初始值&#34;</span>
<span class="nx">result</span><span class="o">=</span><span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
      <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;这是async+await结果&#34;</span><span class="p">);</span> 
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="c1">//打印结果: 这是async+await结果  这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中
</span><span class="c1">//------------------------------------------------------
</span><span class="c1">//在第二个promise中调用使用
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">result2</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nx">result2</span><span class="o">=</span> <span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span> 
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
  <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="o">+</span><span class="s2">&#34;+经过第二个promise加工&#34;</span><span class="p">);</span> 
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span><span class="p">=&gt;{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;第二个promise的then()中打印并返回:&#34;</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>
<span class="k">return</span> <span class="nx">v</span><span class="o">+</span><span class="s2">&#34;,经过then()加工返回&#34;</span>
<span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;最终结果:第二个promise外部结果打印,&#34;</span><span class="p">,</span><span class="nx">result2</span><span class="p">)</span>
<span class="c1">//---------------------------------------------
</span><span class="c1"></span><span class="p">};</span>
<span class="nx">resolveCommon</span><span class="p">()</span>  <span class="c1">//调用普通promise函数
</span><span class="c1"></span><span class="nx">resolveAsync</span><span class="p">()</span>    <span class="c1">//调用await+async
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm">运行结果
</span><span class="cm">1.resolveCommon() 运行结果:    Promise { &lt;pending&gt; }
</span><span class="cm">2.resolveAsync() 运行结果:     
</span><span class="cm">这是async+await结果
</span><span class="cm">第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工
</span><span class="cm">最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回
</span><span class="cm">*/</span>
</code></pre></div><p>原因解析:</p>
<ol>
<li>new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列</li>
</ol>
<p>所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { <!-- raw HTML omitted --> } 对象</p>
<ol start="2">
<li>而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值</li>
</ol>
<p>所以下面的任务就可以使用到这个值</p>
<ol start="3">
<li>为什么这些操作要放在同一个async fn()=&gt;{} 中?</li>
</ol>
<p>1)Promise==&gt;异步</p>
<p>2)await==&gt;异步转同步</p>
<ol>
<li>
<p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</p>
</li>
<li>
<p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行</p>
</li>
</ol>
<p>3)async==&gt;同步转异步</p>
<p>方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</p>
</blockquote>
<h1 id="四宏任务与微任务">四、宏任务与微任务</h1>
<h2 id="-说明">Ⅰ-说明</h2>
<blockquote>
<p>原理图:</p>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Promise系统学习_宏任务微任务原理图"></p>
<p>说明:</p>
<ol>
<li>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</li>
</ol>
<ul>
<li><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</li>
<li><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</li>
</ul>
<ol start="2">
<li>JS执行时会区别这2个队列:</li>
</ol>
<ul>
<li>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</li>
<li>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</li>
<li><strong>同步任务</strong> &ndash;&gt; <strong>微任务</strong> &ndash;&gt; <strong>宏任务</strong></li>
</ul>
</blockquote>
<h2 id="-代码与示例">Ⅱ-代码与示例</h2>
<blockquote>
<p>你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序</p>
</blockquote>
<h3 id="1代码示例">1、代码示例:</h3>
<h4 id="a-首先给出注释的栗子举一个">a) 首先给出注释的栗子举一个</h4>
<blockquote>
<p>此处会给出每个打印放入什么队列,加深你的印象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback1（）&#39;</span><span class="p">)</span><span class="c1">//立即放入宏队列
</span><span class="c1"></span>   <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
     <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved3()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 
</span><span class="c1"></span>     <span class="p">}</span>
   <span class="p">)</span>
 <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>

 <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback2（）&#39;</span><span class="p">)</span> <span class="c1">//立即放入宏队列,
</span><span class="c1"></span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>

 <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
   <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved1()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//立即放入微队列
</span><span class="c1"></span>     <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback3（）&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="c1">//立即放入宏任务
</span><span class="c1"></span>     <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">}</span>
 <span class="p">)</span>

 <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
   <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved2()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//立即放入微队列
</span><span class="c1"></span>   <span class="p">}</span>
 <span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;同步代码&#39;</span><span class="p">)</span> <span class="c1">//同步代码立即执行
</span></code></pre></div><p>结果放在下方,就怕你不小心瞄到</p>
</blockquote>
<h4 id="b-尝试自己思考下">b) 尝试自己思考下</h4>
<blockquote>
<p>尝试自己脑海中用自己理解 &lsquo;运行&rsquo; 一下, 然后把结果写下来,再去下面结果做对比</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;代码开始执行&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;开始for循环&#39;</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
<span class="nx">i</span> <span class="o">==</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="nx">resolve</span><span class="p">()</span>
<span class="p">}</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行then函数&#39;</span><span class="p">))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;代码执行结束&#39;</span><span class="p">);</span>
</code></pre></div></blockquote>
<h3 id="2示例结果">2、示例结果:</h3>
<h4 id="a-第一个栗子的结果">a) 第一个栗子的结果</h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="s1">&#39;同步代码&#39;</span><span class="p">,</span>
<span class="s1">&#39;Promise onResolved1()&#39;</span><span class="p">,</span>
<span class="s1">&#39;Promise onResolved2()&#39;</span><span class="p">,</span>
<span class="s1">&#39;timeout callback1（）&#39;</span><span class="p">,</span>
<span class="s1">&#39;Promise onResolved3()&#39;</span><span class="p">,</span>
<span class="s1">&#39;timeout callback2（）&#39;</span><span class="p">,</span>
<span class="s1">&#39;timeout callback3（）&#39;</span>
</code></pre></div></blockquote>
<h4 id="b-第二个栗子的结果">b) 第二个栗子的结果</h4>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827094130354.png" alt="image-20210827094130354"></p>
<p>PS: 可以忽略<code>undefined</code>这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担.</p>
<p>当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释</p>
</blockquote>
<h1 id="五对浏览器console控制台输出undefined的分析">五、对浏览器console控制台输出undefined的分析</h1>
<h2 id="--出现场景">Ⅰ- 出现场景</h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827095144833.png" alt="image-20210827095144833"></p>
</blockquote>
<h2 id="---尝试输入其他内容进行分析">Ⅱ - 尝试输入其他内容进行分析</h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827095702736.png" alt="image-20210827095702736"></p>
<p>那么做个合理推测: 应该是在控制台输入的内容,它的 <code>返回值</code> 会显示出来,这让我们不禁想到JS的 [ <strong>eval()</strong> ]</p>
</blockquote>
<h2 id="---evalstring">Ⅲ - eval（string）</h2>
<blockquote>
<p>其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值；</p>
<p>如果是没有返回值的表达式或语句，则会返回 undefined ；</p>
<p>如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。</p>
<p>于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数</p>
</blockquote>
<h2 id="---验证一下">Ⅳ - 验证一下</h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827100156570.png" alt="image-20210827100156570"></p>
<p>大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧</p>
</blockquote>
<h2 id="----分析其在宏任务与微任务的打印顺序">Ⅴ -  分析其在宏任务与微任务的打印顺序</h2>
<blockquote>
<p>首先看图:<img src="../../image/Promise_study/image-20210827094130354.png" alt="image-20210827094130354"></p>
<p>可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>三小时AJAX从入门到精通</title>
			<link>https://LeiBuDao.github.io/posts/ajax_study/</link>
			<pubDate>Thu, 10 Mar 2022 15:21:00 +0800</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/ajax_study/</guid>
			<description>AJAX学习的笔记，主要环境为Node.js
建议搭配视频食用：三小时AJAX从入门到精通
第一章： Ajax概述 1.1、Ajax简介   Ajax全称为Asynchronous Javascript And XML，即异步JS和XML 通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据 AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式   1.2 、XML简介    XML：可扩展标记语言
  XML：被设计用来传输和存储数据
  XML和HTML类似，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据
  比如说我有一个学生数据：name = “孙悟空” ; age = 18 ; gender = “男” ; 用XML 表示：
&amp;lt;student&amp;gt; &amp;lt;name&amp;gt;孙悟空&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;18&amp;lt;/age&amp;gt; &amp;lt;gender&amp;gt;男&amp;lt;/gender&amp;gt; &amp;lt;/student&amp;gt;     现在已被JSON取代
{&amp;#34;name&amp;#34;:&amp;#34;孙悟空&amp;#34;,&amp;#34;age&amp;#34;:18,&amp;#34;gender&amp;#34;:&amp;#34;男&amp;#34;}    1.3、 AJAX 的特点 Ⅰ、AJAX的优点   可以无刷新页面与服务端进行通信 允许你根据用户事件来更新部分页面内容   Ⅱ、AJAX 的缺点   没有浏览历史，不能回退 存在跨域问题（同源） SEO不友好（爬虫获取不到信息）   第二章 jQuery中的AJAX 2.</description>
			<content type="html"><![CDATA[<p>AJAX学习的笔记，主要环境为Node.js</p>
<p>建议搭配视频食用：<a href="https://www.bilibili.com/video/BV1WC4y1b78y">三小时AJAX从入门到精通</a></p>
<h2 id="第一章-ajax概述">第一章： Ajax概述</h2>
<h3 id="11ajax简介">1.1、Ajax简介</h3>
<blockquote>
<ul>
<li>Ajax全称为Asynchronous Javascript And XML，即异步JS和XML</li>
<li>通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：<strong>无刷新获取数据</strong></li>
<li>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</li>
</ul>
</blockquote>
<h3 id="12-xml简介">1.2 、XML简介</h3>
<blockquote>
<ul>
<li>
<p>XML：可扩展标记语言</p>
</li>
<li>
<p>XML：被设计用来传输和存储数据</p>
</li>
<li>
<p>XML和HTML类似，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据</p>
<ul>
<li>
<p>比如说我有一个学生数据：name = “孙悟空” ; age = 18 ; gender = “男” ;
用XML 表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">student</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">name</span><span class="p">&gt;</span>孙悟空<span class="p">&lt;/</span><span class="nt">name</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">age</span><span class="p">&gt;</span>18<span class="p">&lt;/</span><span class="nt">age</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">gender</span><span class="p">&gt;</span>男<span class="p">&lt;/</span><span class="nt">gender</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">student</span><span class="p">&gt;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>现在已被JSON取代</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;孙悟空&#34;</span><span class="p">,</span><span class="nt">&#34;age&#34;</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span><span class="nt">&#34;gender&#34;</span><span class="p">:</span><span class="s2">&#34;男&#34;</span><span class="p">}</span>
</code></pre></div></li>
</ul>
</blockquote>
<h3 id="13-ajax-的特点">1.3、 AJAX 的特点</h3>
<h4 id="ajax的优点">Ⅰ、AJAX的优点</h4>
<blockquote>
<ul>
<li>可以无刷新页面与服务端进行通信</li>
<li>允许你根据用户事件来更新部分页面内容</li>
</ul>
</blockquote>
<h4 id="ajax-的缺点">Ⅱ、AJAX 的缺点</h4>
<blockquote>
<ul>
<li>没有浏览历史，不能回退</li>
<li>存在跨域问题（同源）</li>
<li>SEO不友好（爬虫获取不到信息）</li>
</ul>
</blockquote>
<h2 id="第二章-jquery中的ajax">第二章 jQuery中的AJAX</h2>
<h3 id="21mdn文档">2.1、MDN文档</h3>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a></p>
</blockquote>
<h3 id="22http-请求交互的基本过程">2.2、HTTP 请求交互的基本过程</h3>
<blockquote>
<ol>
<li>前后应用从浏览器端向服务器发送HTTP 请求(请求报文)</li>
<li>后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)</li>
<li>浏览器端接收到响应, 解析显示响应体/调用监视回调</li>
</ol>
<p><img src="../../image/AJAX_study/1.png" alt="HTTP 请求交互的基本过程"></p>
</blockquote>
<h3 id="23http请求报文">2.3、HTTP请求报文</h3>
<blockquote>
<ul>
<li>
<p><strong>请求行</strong></p>
<pre tabindex="0"><code>method url
GET /product_detail?id=2
POST /login
</code></pre></li>
<li>
<p><strong>多个请求头</strong></p>
<pre tabindex="0"><code>Host: www.baidu.com
Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;
Content-Type: application/x-www-form-urlencoded 或者application/json
</code></pre></li>
<li>
<p><strong>请求体</strong></p>
<pre tabindex="0"><code>username=tom&amp;pwd=123
{&quot;username&quot;: &quot;tom&quot;, &quot;pwd&quot;: 123}
</code></pre></li>
</ul>
</blockquote>
<h3 id="24http-响应报文">2.4、HTTP 响应报文</h3>
<blockquote>
<ul>
<li>
<p><strong>响应状态行</strong></p>
<pre tabindex="0"><code>status statusText
</code></pre></li>
<li>
<p><strong>多个响应头</strong></p>
<pre tabindex="0"><code>- Content-Type: text/html;charset=utf-8
- Set-Cookie: BD_CK_SAM=1;path=/
</code></pre></li>
<li>
<p><strong>响应体</strong></p>
<pre tabindex="0"><code>html 文本/json 文本/js/css/图片...
</code></pre></li>
</ul>
</blockquote>
<h3 id="25post-请求体参数格式">2.5、post 请求体参数格式</h3>
<blockquote>
<ul>
<li>
<pre tabindex="0"><code>Content-Type: application/x-www-form-urlencoded;charset=utf-8
</code></pre><p>用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接</p>
<p>例如: name=%E5%B0%8F%E6%98%8E&amp;age=12</p>
</li>
<li>
<pre tabindex="0"><code>Content-Type: application/json;charset=utf-8
</code></pre><p>用于 json 字符串参数</p>
<p>例如: {&ldquo;name&rdquo;: &ldquo;%E5%B0%8F%E6%98%8E&rdquo;, &ldquo;age&rdquo;: 12}</p>
</li>
<li>
<pre tabindex="0"><code>Content-Type: multipart/form-data
</code></pre><p>用于文件上传请求</p>
</li>
</ul>
</blockquote>
<h3 id="26常见的响应状态码">2.6、常见的响应状态码</h3>
<blockquote>
<p><code>200 OK</code> ：请求成功。一般用于GET 与POST 请求</p>
<p><code>201 Created </code>：已创建。成功请求并创建了新的资源</p>
<p><code>401 Unauthorized</code> ：未授权/请求要求用户的身份认证</p>
<p><code>404 Not Found</code> ：服务器无法根据客户端的请求找到资源</p>
<p><code>500 Internal Server Error</code> ：服务器内部错误，无法完成请求</p>
</blockquote>
<h3 id="27不同类型的请求及其作用">2.7、不同类型的请求及其作用</h3>
<blockquote>
<p><code>GET</code>: 从服务器端读取数据（查）</p>
<p><code>POST</code>: 向服务器端添加新数据 （增）</p>
<p><code>PUT</code>: 更新服务器端已经数据 （改）</p>
<p><code>DELETE</code>: 删除服务器端数据 （删）</p>
</blockquote>
<h3 id="28api-的分类">2.8、API 的分类</h3>
<blockquote>
<ol>
<li>
<p><strong>REST API</strong>: restful （Representational State Transfer (资源)表现层状态转化）</p>
<p>(1) 发送请求进行CRUD 哪个操作由请求方式来决定</p>
<p>(2) 同一个请求路径可以进行多个操作</p>
<p>(3) 请求方式会用到GET/POST/PUT/DELETE</p>
</li>
<li>
<p><strong>非REST API</strong>: restless</p>
<p>(1) 请求方式不决定请求的CRUD 操作</p>
<p>(2) 一个请求路径只对应一个操作</p>
<p>(3) 一般只有GET/POST</p>
</li>
</ol>
</blockquote>
<h3 id="29区别-一般http请求-与-ajax请求">2.9、区别 一般http请求 与 ajax请求</h3>
<blockquote>
<ol>
<li>
<p>ajax请求 是一种特别的 http请求</p>
</li>
<li>
<p>对服务器端来说, 没有任何区别, 区别在浏览器端</p>
</li>
<li>
<p>浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求</p>
</li>
<li>
<p>浏览器端接收到响应</p>
<p>(1) 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面</p>
<p>(2) ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据</p>
</li>
</ol>
</blockquote>
<h2 id="第三章-原生ajax-的基本使用-xhr">第三章 原生AJAX 的基本使用 XHR</h2>
<h3 id="30-准备工作">3.0 、准备工作</h3>
<h4 id="301-安装nodejs">3.0.1 安装node.js</h4>
<blockquote>
<p><a href="http://nodejs.cn/">http://nodejs.cn/</a></p>
</blockquote>
<h4 id="302-安装express服务端框架">3.0.2 安装express（服务端框架）</h4>
<blockquote>
<p><a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></p>
</blockquote>
<ol>
<li>
<p><strong>初始化环境</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">npm</span> <span class="n">init</span> <span class="o">--</span><span class="n">yes</span>
</code></pre></div></li>
<li>
<p><strong>下载express包</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">npm</span> <span class="n">install</span> <span class="n">express</span> <span class="o">--</span><span class="n">save</span>
</code></pre></div></li>
<li>
<p><strong>编写js代码</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 1. 引入express
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>

<span class="c1">// 2. 创建应用对象
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="c1">// 3. 创建路由规则
</span><span class="c1">// request 是对请求报文的封装
</span><span class="c1">// response 是对响应报文的封装
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">//  设置响应
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&#34;Hello Express&#34;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 4. 监听端口，启动服务
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;服务已经启动, 8000 端口监听中...&#34;</span><span class="p">);</span>
 <span class="p">})</span>
</code></pre></div></li>
<li>
<p><strong>运行js程序</strong></p>
<pre tabindex="0"><code>node express.js
</code></pre></li>
<li>
<p><strong>打开网页显示页面</strong></p>
</li>
</ol>
<p><img src="../../image/AJAX_study/2.png" alt=""></p>
<ol start="6">
<li><strong>调试程序可以查看请求和响应</strong></li>
</ol>
<p><img src="../../image/AJAX_study/3.png" alt=""></p>
<h4 id="303-安装nodemon自动重启工具">3.0.3 安装nodemon自动重启工具</h4>
<blockquote>
<p>文件内容有修改自动重新启动服务:<a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a></p>
</blockquote>
<ul>
<li>
<p>安装:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">nodemon</span>
</code></pre></div></li>
<li>
<p>启动服务:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ndoemon</span> <span class="n">server</span><span class="p">.</span><span class="n">js</span>
</code></pre></div></li>
</ul>
<h3 id="31-理解">3.1、 理解</h3>
<blockquote>
<ol>
<li>使用<code>XMLHttpRequest</code> (XHR)对象可以与服务器交互, 也就是发送ajax 请求</li>
<li>前端可以获取到数据，而无需让整个的页面刷新。</li>
<li>这使得Web 页面可以只更新页面的局部，而不影响用户的操作。</li>
</ol>
</blockquote>
<h3 id="32-核心对象使用步骤">3.2 、核心对象使用步骤</h3>
<h4 id="321-创建xmlhttprequest-对象">3.2.1 创建XMLHttpRequest 对象</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</code></pre></div><h4 id="322-设置请求信息请求方法和url">3.2.2 设置请求信息（请求方法和url）</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 请求方式
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
<span class="c1">//可以设置请求头，一般不设置
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;application/x-www-form-urlencoded&#39;</span><span class="p">);</span>
</code></pre></div><h4 id="323-发送请求">3.2.3 发送请求</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="c1">//get请求不传 body 参数，只有post请求使用
</span></code></pre></div><h4 id="324-接收响应事件绑定处理服务端返回的结果">3.2.4 接收响应（事件绑定，处理服务端返回的结果）</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">//xhr.responseXML 接收 xml格式 的响应数据
</span><span class="c1">//xhr.responseText 接收 文本格式 的响应数据
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
	<span class="c1">// readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">){</span>
		<span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">;</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="33-使用案例">3.3 、使用案例</h3>
<h4 id="331-get-请求">3.3.1 GET 请求</h4>
<blockquote>
<p>创建两个文件，浏览器端使用的html文件和服务器端使用的js文件</p>
</blockquote>
<p><img src="../../image/AJAX_study/4.png" alt=""></p>
<p><strong>服务器端 server.js</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 1. 引入express
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>

<span class="c1">// 2. 创建应用对象
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="c1">// 3. 创建路由规则
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/server&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 设置响应头 设置允许跨域
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Access-Control-Allow-Origin&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
  <span class="c1">// 设置响应体
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&#34;Hello Ajax&#34;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 4. 监听服务
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;服务已经启动, 8000 端口监听中...&#34;</span><span class="p">);</span>
 <span class="p">})</span>

</code></pre></div><p><strong>启动服务</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">node</span> <span class="n">server</span><span class="p">.</span><span class="n">js</span>
</code></pre></div><p><strong>前端页面 html</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;IE=edge&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Ajax GET 请求<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
    <span class="p">#</span><span class="nn">result</span> <span class="p">{</span>
      <span class="k">width</span><span class="p">:</span> <span class="mi">200</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">border</span><span class="p">:</span> <span class="kc">solid</span> <span class="mi">1</span><span class="kt">px</span> <span class="mh">#90b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>点击发送请求<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;result&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">//获取button元素
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;button&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">);</span>
    <span class="c1">//绑定事件
</span><span class="c1"></span>    <span class="nx">btn</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// 1. 创建对象
</span><span class="c1"></span>      <span class="kr">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
      <span class="c1">// 2. 初始化 设置请求方法和url
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://127.0.0.1:8000/server&#39;</span><span class="p">)</span>
      <span class="c1">// 3. 发送
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
      <span class="c1">// 4. 事件绑定 处理服务端返回的结果
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">// readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4
</span><span class="c1"></span>        <span class="c1">//判断 (服务端返回了所有的结果)
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">){</span>
          <span class="c1">//判断响应状态码 200  404  403 401 500
</span><span class="c1"></span>          <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">){</span>
            <span class="c1">// 处理结果 行 头 空行 体
</span><span class="c1"></span>            <span class="c1">// 响应
</span><span class="c1"></span>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;状态码&#39;</span><span class="p">,</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="c1">// 状态码
</span><span class="c1"></span>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;状态字符串&#39;</span><span class="p">,</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span> <span class="c1">// 状态字符串
</span><span class="c1"></span>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;所有响应头&#39;</span><span class="p">,</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">getAllResponseHeaders</span><span class="p">());</span> <span class="c1">// 所有响应头
</span><span class="c1"></span>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;响应体&#39;</span><span class="p">,</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span> <span class="c1">// 响应体
</span><span class="c1"></span>
            <span class="c1">//设置 result 的文本
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">.</span><span class="nx">innerHTML</span><span class="o">=</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
          <span class="p">}</span><span class="k">else</span><span class="p">{</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>

</code></pre></div><p><img src="../../image/AJAX_study/5.gif" alt=""></p>
<p><strong>设置url参数</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#39;</span><span class="p">);</span>
</code></pre></div><p><img src="../../image/AJAX_study/6.png" alt=""></p>
<h4 id="332-post请求">3.3.2 POST请求</h4>
<blockquote>
<p>鼠标放到div中，发post请求，将响应体放在div中呈现</p>
</blockquote>
<p><strong>server.js添加post</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/server&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 设置响应头, 设置允许跨域
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Access-Control-Allow-Origin&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
  <span class="c1">// 设置响应体
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&#34;Hello Ajax POST&#34;</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div><p><strong>post.html</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;IE=edge&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Ajax POST 请求<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
    <span class="p">#</span><span class="nn">result</span> <span class="p">{</span>
      <span class="k">width</span><span class="p">:</span> <span class="mi">200</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">border</span><span class="p">:</span> <span class="kc">solid</span> <span class="mi">1</span><span class="kt">px</span> <span class="mh">#903</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;result&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 获取元素对象
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">);</span>
    <span class="c1">// 绑定事件
</span><span class="c1"></span>    <span class="nx">result</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;mouseover&#34;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// 1. 创建对象
</span><span class="c1"></span>      <span class="kr">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
      <span class="c1">// 2. 初始化 设置类型（请求方式）与url
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;http://127.0.0.1:8000/server&#39;</span><span class="p">);</span>
      <span class="c1">// 3. 发送   设置请求参数（请求体）
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;a=100&amp;b=200&amp;c=300&#39;</span><span class="p">);</span>
      <span class="c1">// 4. 事件绑定
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">// 判断
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">){</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span><span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">){</span>
            <span class="c1">// 处理服务端返回的结果
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>

</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 设置请求体内容的类型
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequesHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;application/x-www-from-urlencoded&#39;</span><span class="p">);</span>
<span class="c1">// 自定义头信息
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequesHeader</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ykyk&#39;</span><span class="p">);</span>
</code></pre></div><p>server.js中设置响应头允许自定义请求头 post改成all</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Access-Control-Allow-Header&#39;</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="p">);</span>
</code></pre></div><h3 id="34-json数据请求">3.4 、json数据请求</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="s1">&#39;/json-server&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 设置响应头, 设置允许跨域
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Access-Control-Allow-Origin&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
  <span class="c1">// 设置响应头, 设置允许自定义头信息
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Access-Control-Allow-Headers&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
  <span class="c1">// 响应一个数据
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;atguigu&#39;</span>
  <span class="p">};</span>
  <span class="c1">// 对 对象 进行 字符串 转换
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="c1">// 设置响应体
</span><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;IE=edge&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>JSON<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
    <span class="p">#</span><span class="nn">result</span> <span class="p">{</span>
      <span class="k">width</span><span class="p">:</span> <span class="mi">200</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">border</span><span class="p">:</span> <span class="kc">solid</span> <span class="mi">1</span><span class="kt">px</span> <span class="mh">#89b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;result&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">);</span>
    <span class="c1">// 绑定键盘按下事件
</span><span class="c1"></span>    <span class="nb">window</span><span class="p">.</span><span class="nx">onkeydown</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// 发送请求
</span><span class="c1"></span>      <span class="kr">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
      <span class="c1">// *2*.(自动转换) 设置响应体数据的类型(自动转换)
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span><span class="p">;</span>
      <span class="c1">// 初始化
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://127.0.0.1:8000/json-server&#39;</span><span class="p">);</span>
      <span class="c1">// 发送
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
      <span class="c1">// 事件绑定
</span><span class="c1"></span>      <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">){</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
            <span class="c1">// 1. 手动对数据转化 (字符串再转换成json)
</span><span class="c1"></span>            <span class="c1">// let data = JSON.parse(xhr.response); //转换成json
</span><span class="c1"></span>            <span class="c1">// result.innerHTML = data.name;
</span><span class="c1"></span>            <span class="c1">// *2*. (自动转换)自动转换(自动转换)
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="c1">//已经自动变成json
</span><span class="c1"></span>          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>

</code></pre></div><h3 id="35-请求超时与网络异常">3.5 、请求超时与网络异常</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 超时设置 （2秒）
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
<span class="c1">// 超时回调
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">ontimeout</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;网络超时，请稍后重试&#39;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 网络异常回调
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;网络异常，请稍后重试&#39;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="36-取消请求">3.6 、取消请求</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 手动取消
</span><span class="c1"></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">abort</span><span class="p">()</span>
</code></pre></div><h3 id="37-请求重复发送问题">3.7 、请求重复发送问题</h3>
<h3 id="38-解决-ie-缓存问题">3.8、 解决 IE 缓存问题</h3>
<blockquote>
<p><strong>问题</strong>：</p>
<p>在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。</p>
<p><strong>解决方式</strong>：</p>
<p>浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;get&#34;</span><span class="p">,</span><span class="s2">&#34;/testAJAX?t=&#34;</span><span class="o">+</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">());</span>
</code></pre></div><h3 id="39-ajax-请求状态">3.9 、AJAX 请求状态</h3>
<blockquote>
<p><code>xhr.readyState</code> 可以用来查看请求当前的状态
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState</a></p>
<ul>
<li><code>0</code>: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用</li>
<li><code>1</code>: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息</li>
<li><code>2</code>: 表示send()方法已经执行，并且头信息和状态码已经收到</li>
<li><code>3</code>: 表示正在接收服务器传来的body 部分的数据</li>
<li><code>4</code>: 表示服务器数据已经完全接收，或者本次接收已经失败了</li>
</ul>
</blockquote>
<h3 id="310-api总结">3.10 、API总结</h3>
<blockquote>
<ul>
<li><code>XMLHttpRequest()</code>：创建 XHR 对象的构造函数</li>
<li><code>status</code>：响应状态码值，如 200、404</li>
<li><code>statusText</code>：响应状态文本，如 ’ok‘、‘not found’</li>
<li><code>readyState</code>：标识请求状态的只读属性 0-1-2-3-4</li>
<li><code>onreadystatechange</code>：绑定 readyState 改变的监听</li>
<li><code>responseType</code>：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应</li>
<li><code>response</code>：响应体数据，类型取决于 responseType 的指定</li>
<li><code>timeout</code>：指定请求超时时间，默认为 0 代表没有限制</li>
<li><code>ontimeout</code>：绑定超时的监听</li>
<li><code>onerror</code>：绑定请求网络错误的监听</li>
<li><code>open()</code>：初始化一个请求，参数为：<code>(method, url[, async])</code></li>
<li><code>send(data)</code>：发送请求</li>
<li><code>abort()</code>：中断请求 （发出到返回之间）</li>
<li><code>getResponseHeader(name)</code>：获取指定名称的响应头值</li>
<li><code>getAllResponseHeaders()</code>：获取所有响应头组成的字符串</li>
<li><code>setRequestHeader(name, value)</code>：设置请求头</li>
</ul>
</blockquote>
<h2 id="第四章-jquery中的ajax">第四章 JQuery中的AJAX</h2>
<h3 id="41-get-请求">4.1 、get 请求</h3>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">[</span><span class="nx">data</span><span class="p">],</span> <span class="p">[</span><span class="nx">callback</span><span class="p">],</span> <span class="p">[</span><span class="nx">type</span><span class="p">])</span>
</code></pre></div><ul>
<li>url:请求的URL 地址</li>
<li>data:请求携带的参数</li>
<li>callback:载入成功时回调函数</li>
<li>type:设置返回内容格式，xml, html, script, json, text, _default</li>
</ul>
</blockquote>
<h3 id="42-post-请求">4.2 、post 请求</h3>
<blockquote>
<pre tabindex="0"><code>$.post(url, [data], [callback], [type])
</code></pre><ul>
<li>url:请求的URL 地址</li>
<li>data:请求携带的参数</li>
<li>callback:载入成功时回调函数</li>
<li>type:设置返回内容格式，xml, html, script, json, text, _default</li>
</ul>
</blockquote>
<h3 id="43-通用方法">4.3 通用方法</h3>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
	<span class="c1">// url
</span><span class="c1"></span>	<span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;http://127.0.0.1:8000/jquery-server&#39;</span><span class="p">,</span>
	<span class="c1">// 参数
</span><span class="c1"></span>	<span class="nx">data</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span><span class="mi">100</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="mi">200</span><span class="p">},</span>
	<span class="c1">// 请求类型
</span><span class="c1"></span>	<span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;GET&#39;</span><span class="p">,</span>
	<span class="c1">// 响应体结果
</span><span class="c1"></span>	<span class="nx">dataType</span><span class="o">:</span> <span class="s1">&#39;json&#39;</span><span class="p">,</span>
	<span class="c1">// 成功的回调
</span><span class="c1"></span>	<span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);},</span>
	<span class="c1">// 超时时间
</span><span class="c1"></span>	<span class="nx">timeout</span><span class="o">:</span> <span class="mi">2000</span><span class="p">,</span>
	<span class="c1">// 失败的回调
</span><span class="c1"></span>	<span class="nx">error</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;出错拉~&#39;</span><span class="p">);},</span>
	<span class="c1">// 头信息
</span><span class="c1"></span>	<span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
		<span class="nx">c</span><span class="o">:</span> <span class="mi">300</span><span class="p">,</span>
		<span class="nx">d</span><span class="o">:</span> <span class="mi">400</span>
	<span class="p">}</span>
<span class="p">})</span>
</code></pre></div></blockquote>
<h2 id="第五章-跨域">第五章 跨域</h2>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000015450909">前端跨域策略实践</a></li>
<li><a href="https://segmentfault.com/a/1190000015597029">不要再问我跨域问题了</a></li>
</ul>
<h3 id="51-同源策略">5.1 、同源策略</h3>
<blockquote>
<ul>
<li>
<p>同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略。</p>
</li>
<li>
<p>同源：协议、域名、端口号 必须完全相同</p>
</li>
<li>
<p>违背同源策略就是跨域</p>
</li>
</ul>
</blockquote>
<h3 id="52-如何解决跨域">5.2 、如何解决跨域</h3>
<h4 id="521-jsonp">5.2.1 JSONP</h4>
<blockquote>
<ol>
<li>
<p><strong>JSONP是什么</strong></p>
<p>JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求。</p>
</li>
<li>
<p><strong>JSONP 怎么工作的？</strong></p>
<p>在网页有一些标签天生具有跨域能力，比如：img, link, iframe, script。</p>
<p>JSONP就是利用<strong>script</strong>标签的跨域能力来发送请求的。</p>
</li>
<li>
<p><strong>JSONP的使用</strong></p>
<ul>
<li>动态的创建一个script标签</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&#34;script&#34;</span><span class="p">);</span>
</code></pre></div><ul>
<li>设置script的src，设置回调函数</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s2">&#34;http://localhost:3000/testAJAX?callback=abc&#34;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">abc</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><ul>
<li>将script 添加到body 中</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
</code></pre></div><ul>
<li>服务器中路由的处理</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">router</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;/testAJAX&#34;</span> <span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span> <span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;收到请求&#34;</span><span class="p">);</span>
	<span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">callback</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
		<span class="nx">name</span><span class="o">:</span><span class="s2">&#34;孙悟空&#34;</span><span class="p">,</span>
		<span class="nx">age</span><span class="o">:</span><span class="mi">18</span>
	<span class="p">}</span>
	<span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">callback</span><span class="o">+</span><span class="s2">&#34;(&#34;</span><span class="o">+</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span><span class="o">+</span><span class="s2">&#34;)&#34;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></li>
<li>
<p><strong>jQuery 中的JSONP</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Title<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
	<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">button</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;btn&#34;</span><span class="p">&gt;</span>按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">ul</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;list&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/javascript&#34;</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./jquery-1.12.3.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/javascript&#34;</span><span class="p">&gt;</span>
			<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
				<span class="kd">var</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;btn&#39;</span><span class="p">)</span>
				<span class="nx">btn</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
					<span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;http://api.douban.com/v2/movie/in_theaters?callback=?&#34;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
						<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
						<span class="c1">//获取所有的电影的条目
</span><span class="c1"></span>						<span class="kd">var</span> <span class="nx">subjects</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">subjects</span><span class="p">;</span>
						<span class="c1">//遍历电影条目
</span><span class="c1"></span>						<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">subjects</span><span class="p">.</span><span class="nx">length</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
							<span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#list&#34;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s2">&#34;&lt;li&gt;&#34;</span><span class="o">+</span>
							<span class="nx">subjects</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">title</span><span class="o">+</span><span class="s2">&#34;&lt;br /&gt;&#34;</span><span class="o">+</span>
							<span class="s2">&#34;&lt;img src=\&#34;&#34;</span><span class="o">+</span><span class="nx">subjects</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">images</span><span class="p">.</span><span class="nx">large</span><span class="o">+</span><span class="s2">&#34;\&#34; &gt;&#34;</span><span class="o">+</span>
							<span class="s2">&#34;&lt;/li&gt;&#34;</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">});</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>

</code></pre></div></li>
</ol>
</blockquote>
<h3 id="522-cors">5.2.2 CORS</h3>
<blockquote>
<p>推荐阅读：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li>
</ul>
<ol>
<li>
<p><strong>CORS是什么？</strong></p>
<p>CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP  首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
</li>
<li>
<p><strong>CORS怎么工作的？</strong></p>
<p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p>
</li>
<li>
<p><strong>CORS 的使用</strong></p>
<p>主要是服务端的设置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">router</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;/testAJAX&#34;</span> <span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span> <span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//通过res 来设置响应头，来允许跨域请求
</span><span class="c1"></span>	<span class="c1">//res.set(&#34;Access-Control-Allow-Origin&#34;,&#34;http://127.0.0.1:3000&#34;);
</span><span class="c1"></span>	<span class="nx">res</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;Access-Control-Allow-Origin&#34;</span><span class="p">,</span><span class="s2">&#34;*&#34;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></li>
</ol>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>2021年度总结</title>
			<link>https://LeiBuDao.github.io/posts/2021_summary/</link>
			<pubDate>Fri, 31 Dec 2021 10:26:06 +0800</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/2021_summary/</guid>
			<description>又是一个碌碌无为的一年。。。
 今天和谢老狗打趣的讨论今年的跨年打算，他随口而出：“不如写下今年的年度总结吧”。刚好我正有此意，与其随着人流哄闹，不如安安静静的坐下来回顾过去的一年。hh，我觉得还是蛮有意义的。【此时舒昂同学已经潇潇洒洒写下几百个大字了，不是吧！这也要卷？】
 可是话又说回来，我这如蝼蚁般平平无奇的一年又有啥可总结的呢。于是乎，我像个无头苍蝇般肆意的翻阅我的社交账号，试图寻找我留下的哪怕是微不足道的印记。现在看起来还是蛮有意思的，那就从头写起吧！
 2020的跨年？也是和谢某人在一起。两个土包子晃晃悠悠来到了新街口，只为一睹中华第一商圈的魅力。出师不利，在出站口绕了好大一圈才出去。看到了孙中山雕塑，去了德基广场，仰望了紫峰大厦。现在只记得是人挤人了，大失所望！只得悻悻而归。刚到宿舍就从抖音刷到大批“跨年”人滞留在新街口，幸灾乐祸！此时的我也丝毫没意识到半个月后的魔鬼生活。
 2021年年初，那时候快要考试了吧，已经经历了像狗一样的大二上的转专业生活，心想着忍忍就能回家嘞。1月上半旬，疫情爆发？南京各大高校相继宣布提前放假，你东按兵不动，有人跳楼、有人喊楼、有人抗议，各种谣言、小道消息满天飞，我也一心想着回家（其实就是不想学习）。1月14日下午三点，院教务在征求我们的意见后考试安排发出，我貌似是十天九门？从当时我的语气看来，我还是蛮乐观的，应该是还在等着教务处的&amp;quot;好消息&amp;quot;？当晚10点50，教务处发出考试安排，原本商量好的安排被换的人不像人鬼不像鬼，那个时候心态已经崩了吧，趴在桌子上，心是在绞痛的，半天喘不上气（没有夸张）。现在那段高强度的复习生活依然历历在目，QAQ，但是已经熬过来了，是吧！1月22日下午，考完计组，魔鬼考试周正式结束，回家啦！
 整个寒假生活都是相当无聊的，我也不出意外的未能实现放假前的“精密学习安排”。
 然后就开学啦！又是悠闲的一个月。。也没有什么好玩的事。
 3月27，我和谢霜【没错，又是他，贯穿了我一整个年度总结的🐕东西】去嘞玄武湖，干嘛呢？看樱花发芽！逛了明城墙【出门匆忙，没带学生证，买了原价票】，吃了山楂糕【十五一个？有点小贵】。照常，都是人，人挤人，不推荐！
 四月份，这可能是印象最深的一个月吧。急性肠炎，肾结石，持续低烧，昏昏的去了同仁医院，自己挂号，自己缴费，自己等报告。也就是那个时候，我想了好多好多啊，再多的钱在医院里也是像哗哗的流水一样。什么年薪百万啊，都是屁，身体健康才是最重要的呀。
 五月份，吃了很多好吃的东西，没有好玩的事情。
 六月份，只记得每周五晚上被算法实验支配的恐惧，然后就是极其讨厌的考试周啦。六月底，考试周结束回家，异常开心。
 七月份，暑期学校，一整个大无语住！虽然一整天都要窝在小小的座位上，但也算是体验了打工人摸鱼的快乐。那段时间啊，喝了很多茶百道，但是我不是很喜欢哎。上着大三的暑校还要补着大二的暑校，可能这就是转专业人的悲哀吧！尤其是被QT以及某於姓老师狠狠的恶心了一把。7月下半旬，南京疫情爆发！可恶的疫情啊！！！七月底，所有转专业的课程正式结束！很久没有那么开心啦，嘿嘿。
 八月份，受到疫情影响，延迟放假，直接开始大三的课程，连续高压学习大半年的我毫无疑问的没有学习的动力了，”嘿嘿嘿，我要放假回家。“ 8月24日晚，打了乒乓球，发现了自己的直板潜能。第二天一早就美美的回家啦。
 九月份，前半段时间还算上纲上线，勉强能够学进去一点东西，后来直接摆烂。。整天浑浑噩噩。。哦对，还拔了一颗牙。社会实践去了黄山，逛了呈坎【很漂亮】、爬了黄山【又怕又累】、游了宏村【很不喜欢】。
 国庆之后继续上课，没了大二的那种高强度的课程压力，我仿佛也感受到了大学的快乐。约约球，吃吃饭，摸摸鱼，快乐！摸着摸着就到年底嘞，突发奇想，在橘园餐厅过了自己的20岁生日，吃了小蛋糕还有好吃的菜，撑的我俩第二天早上都没吃。【写着写着突然想起来居然忘了许愿？？？傻掉了】。十二月份还有一个值得纪念的事情，那就是我的小博客开张啦，在此还得鸣谢王骏同学的悉心指导。不得不说，我在他那里还是学到了不少东西滴【其实是被他带坏了】。
 然后就到了现在啦，还有两个多小时今年就要结束啦。记了这么多流水账，那么我的2021年到底是什么样的呢？像是干了很多事，但是又好像啥也没有做。依然，并没有找到自己真正感兴趣的东西，并没有学到什么东西，并没有做了什么值得纪念的事情。如题，又是碌碌无为的一年。课程内容不想学，作业不想写，选修课也是能水就水，感觉已经没有了大一大二的那股劲头。看到大佬们后又自愧不如，但一转眼又该摆就摆。
 日子好快啊，再过几天我的大三上学期就这么结束了，接着就是面试，实习，夏令营，推免，考研。我也不确定自己有没有准备好，也不知道接下来该怎么走。面试是否能通过？实习是否顺利？能不能拿下夏令营？能不能推免到心仪的学校？如果考研，是否又可以成功上岸。
 啊呀，咋写着写着又emo了捏。总而言之，从寒假开始！一定要冲冲冲！</description>
			<content type="html"><![CDATA[<p>  又是一个碌碌无为的一年。。。</p>
<p>  今天和谢老狗打趣的讨论今年的跨年打算，他随口而出：“不如写下今年的年度总结吧”。刚好我正有此意，与其随着人流哄闹，不如安安静静的坐下来回顾过去的一年。hh，我觉得还是蛮有意义的。【此时舒昂同学已经潇潇洒洒写下几百个大字了，不是吧！这也要卷？】</p>
<p>  可是话又说回来，我这如蝼蚁般平平无奇的一年又有啥可总结的呢。于是乎，我像个无头苍蝇般肆意的翻阅我的社交账号，试图寻找我留下的哪怕是微不足道的印记。现在看起来还是蛮有意思的，那就从头写起吧！</p>
<p>  2020的跨年？也是和谢某人在一起。两个土包子晃晃悠悠来到了新街口，只为一睹中华第一商圈的魅力。出师不利，在出站口绕了好大一圈才出去。看到了孙中山雕塑，去了德基广场，仰望了紫峰大厦。现在只记得是人挤人了，大失所望！只得悻悻而归。刚到宿舍就从抖音刷到大批“跨年”人滞留在新街口，幸灾乐祸！此时的我也丝毫没意识到半个月后的魔鬼生活。</p>
<p>  2021年年初，那时候快要考试了吧，已经经历了像狗一样的大二上的转专业生活，心想着忍忍就能回家嘞。1月上半旬，疫情爆发？南京各大高校相继宣布提前放假，你东按兵不动，有人跳楼、有人喊楼、有人抗议，各种谣言、小道消息满天飞，我也一心想着回家（其实就是不想学习）。1月14日下午三点，院教务在征求我们的意见后考试安排发出，我貌似是十天九门？从当时我的语气看来，我还是蛮乐观的，应该是还在等着教务处的&quot;好消息&quot;？当晚10点50，教务处发出考试安排，原本商量好的安排被换的人不像人鬼不像鬼，那个时候心态已经崩了吧，趴在桌子上，心是在绞痛的，半天喘不上气（没有夸张）。现在那段高强度的复习生活依然历历在目，QAQ，但是已经熬过来了，是吧！1月22日下午，考完计组，魔鬼考试周正式结束，回家啦！</p>
<p>  整个寒假生活都是相当无聊的，我也不出意外的未能实现放假前的“精密学习安排”。</p>
<p>  然后就开学啦！又是悠闲的一个月。。也没有什么好玩的事。</p>
<p>  3月27，我和谢霜【没错，又是他，贯穿了我一整个年度总结的🐕东西】去嘞玄武湖，干嘛呢？看樱花发芽！逛了明城墙【出门匆忙，没带学生证，买了原价票】，吃了山楂糕【十五一个？有点小贵】。照常，都是人，人挤人，不推荐！</p>
<p>  四月份，这可能是印象最深的一个月吧。急性肠炎，肾结石，持续低烧，昏昏的去了同仁医院，自己挂号，自己缴费，自己等报告。也就是那个时候，我想了好多好多啊，再多的钱在医院里也是像哗哗的流水一样。什么年薪百万啊，都是屁，身体健康才是最重要的呀。</p>
<p>  五月份，吃了很多好吃的东西，没有好玩的事情。</p>
<p>  六月份，只记得每周五晚上被算法实验支配的恐惧，然后就是极其讨厌的考试周啦。六月底，考试周结束回家，异常开心。</p>
<p>  七月份，暑期学校，一整个大无语住！虽然一整天都要窝在小小的座位上，但也算是体验了打工人摸鱼的快乐。那段时间啊，喝了很多茶百道，但是我不是很喜欢哎。上着大三的暑校还要补着大二的暑校，可能这就是转专业人的悲哀吧！尤其是被QT以及某於姓老师狠狠的恶心了一把。7月下半旬，南京疫情爆发！可恶的疫情啊！！！七月底，所有转专业的课程正式结束！很久没有那么开心啦，嘿嘿。</p>
<p>  八月份，受到疫情影响，延迟放假，直接开始大三的课程，连续高压学习大半年的我毫无疑问的没有学习的动力了，”嘿嘿嘿，我要放假回家。“ 8月24日晚，打了乒乓球，发现了自己的直板潜能。第二天一早就美美的回家啦。</p>
<p>  九月份，前半段时间还算上纲上线，勉强能够学进去一点东西，后来直接摆烂。。整天浑浑噩噩。。哦对，还拔了一颗牙。社会实践去了黄山，逛了呈坎【很漂亮】、爬了黄山【又怕又累】、游了宏村【很不喜欢】。</p>
<p>  国庆之后继续上课，没了大二的那种高强度的课程压力，我仿佛也感受到了大学的快乐。约约球，吃吃饭，摸摸鱼，快乐！摸着摸着就到年底嘞，突发奇想，在橘园餐厅过了自己的20岁生日，吃了小蛋糕还有好吃的菜，撑的我俩第二天早上都没吃。【写着写着突然想起来居然忘了许愿？？？傻掉了】。十二月份还有一个值得纪念的事情，那就是我的小博客开张啦，在此还得鸣谢王骏同学的悉心指导。不得不说，我在他那里还是学到了不少东西滴【其实是被他带坏了】。</p>
<p>  然后就到了现在啦，还有两个多小时今年就要结束啦。记了这么多流水账，那么我的2021年到底是什么样的呢？像是干了很多事，但是又好像啥也没有做。依然，并没有找到自己真正感兴趣的东西，并没有学到什么东西，并没有做了什么值得纪念的事情。如题，又是碌碌无为的一年。课程内容不想学，作业不想写，选修课也是能水就水，感觉已经没有了大一大二的那股劲头。看到大佬们后又自愧不如，但一转眼又该摆就摆。</p>
<p>  日子好快啊，再过几天我的大三上学期就这么结束了，接着就是面试，实习，夏令营，推免，考研。我也不确定自己有没有准备好，也不知道接下来该怎么走。面试是否能通过？实习是否顺利？能不能拿下夏令营？能不能推免到心仪的学校？如果考研，是否又可以成功上岸。</p>
<p>  啊呀，咋写着写着又emo了捏。总而言之，从寒假开始！一定要冲冲冲！</p>
]]></content>
		</item>
		
		<item>
			<title>软件体系结构期末复习</title>
			<link>https://LeiBuDao.github.io/posts/safinalexam/</link>
			<pubDate>Tue, 21 Dec 2021 15:04:19 +0800</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/safinalexam/</guid>
			<description>第一章—软件体系结构概述 1、软件体系结构的主要思想  软件架构是一个软件系统的设计图，并不局限于软件系统的总体结构，还包含一些质量属性以及功能与结构之间的映射关系，即设计决策。 软件架构的两个主要焦点集中于系统的总体结构以及需求和实现之间的对应。 软件架构的主要思想是将注意力集中在系统总体结构的组织上。  2、软件架构的特征    特征 实现方式 作用     注重可重用性 组件及架构级重用 提高软件质量   利益相关者众多 满足各利益相关者需求 平衡需求   关注点分离 分而治之、模块化 简化复杂性   质量驱动 使用软件架构来处理质量属性需求、控制复杂性 由功能、数据流驱动向质量驱动转变   概念完整性 强调设计决策是一个持续的过程 每个决策都要在其前面设计决策的基础上进行   循环风格 架构风格、架构模式 用标准方法来处理反复出现的问题    3、软件架构的发展阶段  （1）无体系结构  ​ 高级语言出现
  （2）基础研究阶段（1968-1994）
​ 面向过程开发
  （3）核心技术形成（1991-2000）
  ​ 面向对象开发
​ 1）软件架构作为一个独立的研究领域出现
​ 2）软件架构核心技术的发展</description>
			<content type="html"><![CDATA[<h2 id="第一章软件体系结构概述">第一章—软件体系结构概述</h2>
<h3 id="1软件体系结构的主要思想">1、软件体系结构的主要思想</h3>
<ul>
<li>软件架构是一个软件系统的设计图，并不局限于软件系统的总体结构，还包含一些质量属性以及功能与结构之间的映射关系，即设计决策。</li>
<li>软件架构的两个主要焦点集中于系统的总体结构以及需求和实现之间的对应。</li>
<li>软件架构的主要思想是将注意力集中在系统总体结构的组织上。</li>
</ul>
<h3 id="2软件架构的特征">2、软件架构的特征</h3>
<table>
<thead>
<tr>
<th>特征</th>
<th>实现方式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>注重可重用性</td>
<td>组件及架构级重用</td>
<td>提高软件质量</td>
</tr>
<tr>
<td>利益相关者众多</td>
<td>满足各利益相关者需求</td>
<td>平衡需求</td>
</tr>
<tr>
<td>关注点分离</td>
<td>分而治之、模块化</td>
<td>简化复杂性</td>
</tr>
<tr>
<td>质量驱动</td>
<td>使用软件架构来处理质量属性需求、控制复杂性</td>
<td>由功能、数据流驱动向质量驱动转变</td>
</tr>
<tr>
<td>概念完整性</td>
<td>强调设计决策是一个持续的过程</td>
<td>每个决策都要在其前面设计决策的基础上进行</td>
</tr>
<tr>
<td>循环风格</td>
<td>架构风格、架构模式</td>
<td>用标准方法来处理反复出现的问题</td>
</tr>
</tbody>
</table>
<h3 id="3软件架构的发展阶段">3、软件架构的发展阶段</h3>
<ul>
<li><strong>（1）无体系结构</strong></li>
</ul>
<p>​                 高级语言出现</p>
<ul>
<li>
<p><strong>（2）基础研究阶段（1968-1994）</strong></p>
<p>​          面向过程开发</p>
</li>
<li>
<p><strong>（3）核心技术形成（1991-2000）</strong></p>
</li>
</ul>
<p>​                 面向对象开发</p>
<p>​                1）软件架构作为一个独立的研究领域出现</p>
<p>​                2）软件架构核心技术的发展</p>
<p>​                3）软件组件技术</p>
<ul>
<li><strong>（4）理论体系丰富（1996-1999）</strong></li>
</ul>
<p>​                 面向服务开发</p>
<ul>
<li><strong>（5）理论体系完善及普及应用（1999-至今）</strong></li>
</ul>
<p>​                 云和移动服务、智能化软件开发</p>
<h2 id="第二章软件架构定义">第二章—软件架构定义</h2>
<h3 id="1概述">1、概述</h3>
<ul>
<li>组成派关注于软件本身，将软件架构看做组件和交互的集合。</li>
<li>决策派关注于架构中的实体(人)，将软件架构视为一系列重要设计决策的集合。</li>
</ul>
<h3 id="2组成派定义">2、组成派定义</h3>
<p>依据：软件架构主要反映系统由哪些部分组成，以及这些部分是如何组成的，强调系统的整体结构和配置。</p>
<p>（1）1992 —Dewane Perry &amp; Alexander Wolf</p>
<p>​    软件架构 = {元素、组成、原理}</p>
<ul>
<li>
<p>架构元素：，具有一定形式的结构元素，包括处理元素、数据元素、连接元素</p>
</li>
<li>
<p>架构组成：</p>
<ul>
<li>
<p>加权的属性：约束架构的选择</p>
</li>
<li>
<p>关系：约束架构元素的放置</p>
</li>
</ul>
</li>
<li>
<p>架构原理：捕获在选择架构风格、架构元素和架构形式的选择动机。</p>
</li>
</ul>
<p>（2）Mary Shaw &amp; David Carlan</p>
<p>软件架构包括组件、连接件和约束三大要素。</p>
<ul>
<li>组件：可以是一组代码，也可以是独立的程序。</li>
<li>连接件：可以是过程调用、管道和消息等，用于表示组件间的相互关系。</li>
<li>约束：组件连接时的条件。</li>
</ul>
<p>（3）2011年 ISO/IEC/IEEE标准</p>
<p>软件架构是某一系统的基本组织结构，其内容包括软件组件、组件间的联系、组件与其环境间的关系，以及指导上述内容设计与演化的原理。</p>
<h3 id="3决策派定义">3、决策派定义</h3>
<p>依据：软件架构是软件设计的一部分，软件设计实际上是开发人员意志和决策在软件开发过程中的体现，更是高层领导和软件架构师意志和决策的体现。强调设计决策，更加注重架构风格和模式选择。</p>
<h3 id="4参考定义框架">4、参考定义框架</h3>
<p>组件（Component）、连接件（Connector）、配置（Configuration）、端口（Port）、角色（Role）</p>
<ul>
<li>组件：具有某种功能的可重用的软件模块单元。</li>
<li>连接件：表示了组件之间的交互。</li>
<li>配置：表示了组件和连接件的拓扑逻辑和约束。</li>
<li>端口：组件的接口由一组端口组成，每个端口表示了组件和外部环境的交汇点。</li>
<li>角色：连接件的接口由一组角色组成，连接件的每个角色定义了该连接件表示的交互的参与者。
<ul>
<li>二元连接件有两个角色</li>
<li>有的连接件有多于两个的角色</li>
</ul>
</li>
</ul>
<h2 id="第三章软件架构模型">第三章—软件架构模型</h2>
<p><em><strong>至今没有一种建模方法能够满足软件架构建模的所有要求。</strong></em></p>
<h3 id="1软件架构的五类建模方法过程缺点">1、软件架构的五类建模方法（过程、缺点）。</h3>
<h4 id="基于非规范的图形表示的建模方法">①基于非规范的图形表示的建模方法</h4>
<p><strong>图形可视化是将软件架构按照图形的方式进行表达，需要便于涉众阅读、理解和交流，使之不会因图形过于复杂而难以把握架构的概况</strong></p>
<ul>
<li>
<p>非正式图形表示：盒线图</p>
</li>
<li>
<p>正式图形表示：</p>
<ul>
<li>
<p>树形结构：</p>
<p>（1）是显示层次性软件架构的理想方法。</p>
<p>（2）难以处理复杂的问题。</p>
</li>
<li>
<p>树地图（TreeMap）</p>
<p>底层盒子往往用于表示方法，组合盒子往往用于表示类。</p>
<p>（1）是展示整个软件层次架构的有效方法。</p>
<p>（2）实质是一种空间填充方法。</p>
</li>
<li>
<p>改进的树地图</p>
</li>
<li>
<p>冰块图（Icicle Plot）</p>
<p>每一行代表树的一个层次，按照子节点的数量进行分割。</p>
<p>（1）有助于理解结构化的关系。</p>
<p>（2）对于大型系统的层次化架构，这种可视化技术的扩展性和导航性存在问题。</p>
</li>
<li>
<p>旭日图（SunBurst）</p>
<p>（1）具有较好的弹性：图中元素的角度和颜色。</p>
<p>（2）与树地图相比，更易学习且更令人舒适。</p>
</li>
<li>
<p>双曲图（Hyperbolic）</p>
<p>（1）双曲空间比欧几里得空间有更多的显示空间。</p>
</li>
</ul>
</li>
</ul>
<h4 id="基于uml的建模方法">②基于UML的建模方法</h4>
<p>用例图、类图、状态图、协作图、序列图、活动图、包图、组件图、部署图、复合结构、交互概述图、时序图</p>
<table>
<thead>
<tr>
<th style="text-align:center">架构元素</th>
<th style="text-align:center">UML模型组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组件</td>
<td style="text-align:center">分类器（如类、组件、节点、用例等）</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:center">接口</td>
</tr>
<tr>
<td style="text-align:center">关系（连接器）</td>
<td style="text-align:center">关系（如泛化、关联、依赖等）</td>
</tr>
<tr>
<td style="text-align:center">约束（规则）</td>
<td style="text-align:center">规则</td>
</tr>
</tbody>
</table>
<p>用UML建模的三种方法：</p>
<ul>
<li>（1）将UML看作是一种软件架构描述语言直接对架构建模。</li>
<li>（2）通过扩展机制约束UML的元模型以支持软件架构模型的需要。</li>
<li>（3）对UML的元模型进行扩充。</li>
</ul>
<h4 id="基于形式化的建模方法">③基于形式化的建模方法</h4>
<p>Z语言、Petri网、过滤器模式、B语言、VDM、CSP</p>
<h4 id="基于uml形式化的方法">④基于UML形式化的方法</h4>
<p>UML不是一种形式化的语言</p>
<p><strong>形式化与UML结合的建模过程：</strong></p>
<p>需求分析—&gt;需求文档规格说明—&gt;UML建模—&gt;形式化描述—&gt;程序编码—&gt;测试变量（形式规范自动生成）—&gt;软件产品</p>
<ul>
<li>注意：前四步占全部工作量的60-70%</li>
</ul>
<h4 id="其他建模方法文本语言mda">⑤其他建模方法（文本语言、MDA）</h4>
<p><strong>文本语言建模方法</strong></p>
<ul>
<li>
<p>文本语言建模是通过文本文件描绘架构，这些文本文件通常需要符合某些特殊的句法格式。</p>
</li>
<li>
<p>可用方法：语法高亮显示、文本的静态检查、自动补全、代码折叠</p>
</li>
<li>
<p>种类：XML文本建模方法、xADLite文本建模方法</p>
</li>
<li>
<p>优势：</p>
<p>（1）单个文档中描述整体架构，并且存在众多文本编辑器方便用户与文本文档的交互</p>
<p>（2）许多工具能够生成程序库来对使用该语言的文本文档进行句法分析和检查。</p>
<p>（3）许多编辑器附带额外的开发支持工具。</p>
</li>
<li>
<p>缺点：</p>
<p>（1）用文本语言建模方法表示类图形结构就不易理解。</p>
<p>（2）文本编辑器通常限于显示满屏的文本，很难以另外的方式组织文本。</p>
</li>
</ul>
<p><strong>MDA</strong></p>
<ul>
<li>MDA不是一个实现分布式系统的软件架构，而是一个模型技术进行软件开发的方法</li>
<li>MDA将模型区分为PIM和PSM
<ul>
<li>平台无关模型（PIM）：PIM是一个系统的形式化规范，它与具体的实现技术无关。</li>
<li>平台相关模型（PSM）：PSM基于某一具体目标平台的形式化规范。</li>
</ul>
</li>
<li>它的核心思想是抽象出与实现技术无关、完整描述业务功能的平台独立模型。</li>
</ul>
<h3 id="241模型">2、“4+1”模型</h3>
<h4 id="1逻辑视图支持行为要求">（1）逻辑视图：支持行为要求。</h4>
<ul>
<li>描述系统各部分的抽象描述。用于建模系统的组成部分以及各组成部分之间的交互方式。</li>
<li>通常包括类图、对象图、状态图和协作图。</li>
</ul>
<h4 id="2过程视图解决并发和分发">（2）过程视图：解决并发和分发。</h4>
<ul>
<li>描述系统中的进程。 当可视化系统中一定会发生的事情时，此视图特别有用。</li>
<li>该视图通常包含活动图、顺序图等。</li>
</ul>
<h4 id="3开发视图组织软件模块库子系统开发单元">（3）开发视图：组织软件模块，库，子系统，开发单元。</h4>
<ul>
<li>描述系统的各部分如何被组织为模块和组件。</li>
<li>该视图通常包含包图和组件图。</li>
<li>管理系统体系结构中的层非常有用。</li>
</ul>
<h4 id="4物理视图将其他元素映射到处理和通信节点">（4）物理视图：将其他元素映射到处理和通信节点。</h4>
<ul>
<li>
<p>描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体</p>
</li>
<li>
<p>该视图通常包含部署图，展示了抽象部分如何映射到最终部署的系统中。</p>
</li>
</ul>
<h4 id="5用例视图将其他视图映射到重要的用例这些用例被称作场景上对体系结构加以说明">（5）用例视图：将其他视图映射到重要的用例（这些用例被称作场景）上对体系结构加以说明。</h4>
<ul>
<li>从外部世界的角度描述正在建模的系统的功能。</li>
<li>需要使用此视图来描述系统应该执行的操作。 所有其他视图都依靠用例视图（场景）来指导，这就是将模型称为4 + 1的原因。</li>
<li>该视图通常包含用例图，描述和概述图。</li>
</ul>
<h2 id="第四章软件架构风格">第四章—软件架构风格</h2>
<h3 id="1什么是软件架构风格">1、什么是软件架构风格？</h3>
<ul>
<li>
<p>软件体系风格描述了一类体系结构，独立于实际问题，强调了软件系统中通用的组织结构，在实践中被多次应用，是若干设计思想的综合，具有已经被熟知的特性，并且可以被复用。</p>
</li>
<li>
<p>软件架构风格又称软件架构惯用模式，是描述某一特定应用领域中系统组织方式的惯用模式，作为“可复用的组织模式和习语”，为设计人员的交流提供了公共的术语空间，促进了设计复用与代码复用。</p>
</li>
</ul>
<h3 id="2使用架构风格的好处">2、使用架构风格的好处。</h3>
<p>（1）可以极大的促进设计的重用性和代码的重用性，并且使得系统的组织结构易被理解。</p>
<p>（2）使用标准的架构风格可较好地支持系统内部的互操作性以及针对特定风格的分析。</p>
<h3 id="3经典体系结构风格的特点优缺点适用范围组件连接件约束">3、经典体系结构风格的特点、优缺点、适用范围。（组件、连接件、约束）</h3>
<h4 id="31管道过滤器风格">3.1、管道过滤器风格</h4>
<ul>
<li>
<p>基本组件：过滤器（功能模块）</p>
<ul>
<li>
<p>每个过滤器组件中都封装了一个处理步骤</p>
</li>
<li>
<p>数据源点和数据终点可以看作是特殊的过滤器</p>
</li>
</ul>
</li>
<li>
<p>连接件：管道（数据流）</p>
</li>
<li>
<p>过滤器Filter：</p>
<ul>
<li>作用：将源数据变换为目标数据</li>
<li>变换方式：（丰富）增加、（精炼）删除、（转换）改变、分解、合并等</li>
<li>特性：独立性
<ul>
<li>（1）过滤器独立完成自身功能，相互之间无需进行状态交互</li>
<li>（2）过滤器自身无状态</li>
<li>（3）过滤器对其上下游的过滤器“无知”</li>
</ul>
</li>
</ul>
</li>
<li>
<p>管道Pipe：</p>
<ul>
<li>作用：将数据从一个过滤器的输出口转移到另一个过滤器的输入口</li>
<li>过滤器是单向移动的。</li>
<li>过滤器可以有缓冲区。</li>
</ul>
</li>
<li>
<p><strong>结果的正确性不依赖于各个过滤器运行的先后顺序</strong></p>
</li>
<li>
<p>优点：</p>
<ul>
<li>（1）由于每个组件行为不受其他组件的影响，整个系统的行为易于理解。</li>
<li>（2）管道-过滤器风格支持功能模块的复用。</li>
<li>（3）具有较强的可维护性和可拓展性</li>
<li>（4）支持一些特定的分析，如吞吐量计算和死锁检测等。</li>
<li>（5）具有并发性。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>（1）往往导致系统处理过程的成批操作。</li>
<li>（2）增加了过滤器具体实现的复杂性，系统性能不高。</li>
<li>（3）交互式处理能力弱。</li>
</ul>
</li>
<li>
<p>应用场景：数据源源不断的产生，系统需要对这些数据进行若干处理。</p>
</li>
</ul>
<h4 id="32主程序子程序风格">3.2、主程序/子程序风格</h4>
<ul>
<li>组件：程序和明确可见的数据（程序=数据结构+算法）</li>
<li>连接件：程序调用和数据共享</li>
<li>约束：单线程</li>
<li>优点：
<ul>
<li>（1）结构化程序设计的典型风格，相对于非结构化设计逻辑清晰，易理解。</li>
<li>（2）开发过程采用逐步细化，将大系统分解为若干模块。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>（1）对数据存储格式的变化将会影响几乎所有的模块。</li>
<li>（2）在规模变大时将会难理解。</li>
<li>（3）难以支持有效的复用。</li>
</ul>
</li>
<li>应用场景：它适用于可以通过过程定义的层次结构适当地定义计算的应用程序。</li>
</ul>
<h4 id="33面向对象风格">3.3、面向对象风格</h4>
<ul>
<li>特点：
<ul>
<li>（1）对象负责维护其表示的完整性；</li>
<li>（2）对象的表示对其他对象而言是隐蔽的。抽象数据类型的使用，以及面向对象系统的使用已经非常普遍。</li>
</ul>
</li>
<li>应用场景：它适用于中心问题是识别和保护相关信息体（尤其是表示信息）的应用程序。</li>
<li>组件：管理器（例如，服务器、对象、抽象数据类型）</li>
<li>连接件：程序调用</li>
<li>约束：分散的，通常是单线程</li>
<li>优点：
<ul>
<li>（1）对象隐藏了其实现细节，使得对象的使用变得简单方便，而且具有很高的安全性和可靠性。</li>
<li>（2）设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>（1）管理多个对象</li>
<li>（2）管理许多交互</li>
<li>（3）行为的分布式责任，难以理解</li>
<li>（4）捕获相关设计的族</li>
</ul>
</li>
</ul>
<h4 id="34层次化风格">3.4、层次化风格</h4>
<ul>
<li>特点：
<ul>
<li>（1）每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。</li>
<li>（2）大的问题分解为若干渐进的小问题，逐步解决，隐藏了很多复杂度。</li>
<li>（3）修改一层，最多影响两层，而通常只能影响上层。接口稳固，见谁都不影响。</li>
<li>（4）上层必须知道下层的身份，不能调整层次之间的顺序。</li>
</ul>
</li>
<li>应用场景：它适用于涉及可以分层排列的不同服务类的应用程序。</li>
<li>组件：通常是复合的，例如程序的集合。</li>
<li>连接件：取决于组件的结构；通常是在受限的可见性下进行的过程调用。</li>
<li>约束：单线程</li>
<li>优点：
<ul>
<li>（1）支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。</li>
<li>（2）支持扩展。【维护、修改比较容易】</li>
<li>（3）支持重用。【接口稳定】</li>
</ul>
</li>
<li>缺点：
<ul>
<li>（1）不是所有系统都容易用这种模式来构建；</li>
<li>（2）定义一个合适的抽象层次可能会非常困难，特别是对于标准化的层次模型。</li>
<li>（3）层层相调，影响性能。</li>
</ul>
</li>
</ul>
<h4 id="35事件驱动风格">3.5、事件驱动风格</h4>
<ul>
<li>
<p><strong>基本思想</strong>：组件不直接调用一个过程，而是发布或广播一个或多个事件。</p>
</li>
<li>
<p><strong>特点</strong>：事件的触发者并不知道哪些构件会被这些事件影响，相互保持独立。</p>
</li>
<li>
<p><strong>事件分派策略</strong>：广播式、选择广播式</p>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>（1）组件之间关联较弱，一个组件出错将不会影响其他构件。</li>
<li>（2）提高软件的复用能力。</li>
<li>（3）系统便于升级。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>（1）组件放弃了对计算机的控制权，完全由系统决定。</li>
<li>（2）存在数据交换问题。</li>
<li>（3）该风格中，正确性验证成为一个问题。</li>
</ul>
</li>
</ul>
<h4 id="36解释器风格">3.6、解释器风格</h4>
<ul>
<li>
<p><strong>解释器&amp;编译器</strong></p>
<ul>
<li>编译器不会执行输入的源程序代码，而是将其翻译为另一种语言，并输出到文件中以便随后链接为可执行文件并加以执行；在解释器中程序源代码被解释器直接加以执行。</li>
<li>解释器的执行速度要慢于编译器产生目标代码的执行速度，却低于编译器“编译+链接+执行”的总时间。</li>
</ul>
</li>
<li>
<p><strong>解释器的三种策略</strong></p>
<ul>
<li>传统解释器:纯粹的解释执行</li>
<li>基于字节码的解释器：编译为字节码—&gt;解释执行</li>
<li>JIT编译器：编译||解释执行（模糊了解释器、字节码解释器和编译器之间的边界与区分）</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>（1）有利于实现程序的可移植性和语言的跨平台能力。</li>
<li>（2）可以对未来的硬件进行模拟和仿真，降低测试所带来的复杂性和昂贵花费。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>（1）额外的间接层次导致了系统性能的下降。</li>
</ul>
</li>
</ul>
<h4 id="37基于规则的系统风格">3.7、基于规则的系统风格</h4>
<ul>
<li>
<p><strong>核心思想</strong></p>
<ul>
<li>将业务逻辑中可能频繁发生变化的代码从源代码中分离出来。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>（1）降低了修改业务逻辑的成本。</li>
<li>（2）缩短了开发时间。</li>
<li>（3）将规则外部化，可在多个应用之间共享。</li>
<li>（4）对规则的改变将会非常迅速并且具有较低的风险。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>（1）额外的间接层次导致了系统性能的下降。</li>
</ul>
</li>
</ul>
<h4 id="38仓库风格">3.8、仓库风格</h4>
<ul>
<li><strong>应用场景</strong>：应用于核心问题是建立、扩充和维护一个复杂的中央信息体的情况。
<ul>
<li>数据处理，主要需要用传统的数据库来搭建业务决策系统。</li>
<li>软件开发环境，主要需要表示和操作相关的程序和设计。</li>
</ul>
</li>
<li><strong>组件</strong>：
<ul>
<li>中心数据结构组件，表示当前数据的状态。</li>
<li>相对独立的组件集合，各个功能模块（子系统）等。</li>
</ul>
</li>
<li><strong>连接件</strong>：数据仓库与独立组件之间的交互
<ul>
<li>由输入流中事务触发系统相应的进程执行—&gt;数据库型知识库。</li>
<li>由中心数据结构的当前状态触发系统相应的进程执行—&gt;黑板知识库。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>（1）便于模块间的数据共享。</li>
<li>（2）方便模块的添加、更新和删除。</li>
<li>（3）避免了知识源的不必要的重复存储等。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）对于各个模块，需要一定的同步/加锁机制保证数据结构的完整性和一致性等。</li>
</ul>
</li>
</ul>
<h4 id="39黑板系统风格">3.9、黑板系统风格</h4>
<ul>
<li><strong>组成部分</strong>
<ul>
<li>知识源：是描述某个独立领域问题的知识及其处理方法的知识库。</li>
<li>黑板数据结构：</li>
<li>控制器：时刻监视黑板状态变化</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>（1）便于多客户共享大量数据。</li>
<li>（2）即便于添加新的作为知识源代理的应用程序，也便于扩展共享的黑板数据结构。</li>
<li>（3）知识源可重用。</li>
<li>（4）支持容错性和健壮性。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）不同的知识源代理对于共享数据结构要达成一致，这也造成了对黑板数据结构的修改较为困难—要考虑到各个代理的调用。</li>
<li>（2）需要一定的同步/加锁机制保证数据结构的完整性和一致性，增大了系统复杂度。</li>
</ul>
</li>
</ul>
<h4 id="310c2风格">3.10、C2风格</h4>
<p>通过连接件绑定在一起的按照一组规则运作的并行组件网络。该规则规定了所有组件之间的交互必须是通过异步消息机制来实现。【不能跨层连接】</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>（1）可使用任何编程语言开发组件，组件重用和替换易实现。</li>
<li>（2）组件相互独立，依赖较小，具有一定的扩展能力，可支持不同粒度的组件。</li>
<li>（3）组件不需要共享地址空间。</li>
<li>（4）可实现多个用户和多个系统之间的交互。</li>
<li>（5）可使用多个工具集和多媒体类型，动态更新系统框架结构。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）不太适合大规模流式风格系统，以及对数据库使用比较频繁的使用。</li>
</ul>
</li>
</ul>
<h4 id="311cs风格">3.11、C/S风格</h4>
<p><strong>两层C/S架构</strong></p>
<ul>
<li>优点：
<ul>
<li>(1)客户机组件和服务器组件分别运行在不同的计算机上，有利于分布式数据的组织和处理。</li>
<li>(2)组件之间的位置是相互透明的。</li>
<li>(3)客户机程序和服务器程序可运行在不同的操作系统上，便于实现异构环境和多种不同开发技术的融合。</li>
<li>(4)软件环境和硬件环境的配置具有极大的灵活性，易于系统功能的扩展。</li>
<li>(5)将大规模的业务逻辑分布到多个通过网络连接的低成本的计算机上，降低了系统的整体开销。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>(1)开发成本较高(客户机的软硬件要求高)。</li>
<li>(2)客户机程序的设计复杂度大，客户机负荷重。</li>
<li>(3)信息内容和形式单一。</li>
<li>(4)C/S架构升级需要开发人员到现场更新客户机程序，对运行环境进行重新配置，增加了维护费用。</li>
<li>(5)两层C/S结构采用了单一的服务器，同时以局域网为中心，难以扩展到Internet。</li>
<li>(6)数据安全性不高，客户端程序可以直接访问数据库数据。</li>
</ul>
</li>
</ul>
<p><strong>三层C/S架构</strong></p>
<ul>
<li>
<p>相比于两层的优点</p>
<ul>
<li>(1)合理地划分三层结构的功能，可以使系统的逻辑结构更加清晰，提高软件的可维护性和可扩充性。</li>
<li>(2)在实现三层C/S架构时，可以更有效地选择运行平台和硬件环境，从而使每一层都具有清晰的逻辑结构、良好的负荷处理能力和较好的开放性。</li>
<li>(3)在C/S架构中，可以分别选择合适的编程语言并行开发。</li>
<li>(4)系统具有较高的安全性。</li>
</ul>
</li>
<li>
<p>需要注意的问题</p>
<ul>
<li>
<p>(1)如果各层之间的通信效率不高，即使每一层的硬件配置都很高，系统的整体性能也不会太高。</p>
</li>
<li>
<p>(2)必须慎重考虑三层之间的通信方法、通信频率和传输数据量，这和提高各层的独</p>
<p>立性一样也是实现三层C/S架构的关键性问题。</p>
</li>
</ul>
</li>
</ul>
<h4 id="312bs风格">3.12、B/S风格</h4>
<ul>
<li><strong>优点</strong>
<ul>
<li>（1）客户端只需要安装浏览器，操作简单，能够发布动态信息和静态信息。</li>
<li>（2）运用HTTP标准协议和统一客户端软件，能够实现跨平台通信。</li>
<li>（3）开发成本比较低，只需要维护Web服务器程序和中心数据库。客户端升级可以通过升级浏览器来实现。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）个性化程度比较低，所有客户端程序的功能都是一样的。</li>
<li>（2）客户端数据处理能力比较差，加重了Web服务器的工作负担，影响系统的整体性能。</li>
<li>（3）在B/S架构中，数据提交一般以页面为单位，动态交互性不强，不利于在线事务处理。</li>
<li>（4）B/S架构的可扩展性比较差，系统安全性难以保障。</li>
<li>（5）B/S架构的应用系统查询中心数据库，其速度要远低于C/S架构。</li>
</ul>
</li>
</ul>
<h4 id="313平台插件风格">3.13、平台/插件风格</h4>
<p>将待开发的目标软件分为两个部分：（1）程序的主体框架，可定义为平台。 （2）功能扩展或补充模块，可定义为插件。</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>（1）降低系统各模块之间的互依赖性。</li>
<li>（2）系统模块独立开发、部署、维护。</li>
<li>（3）根据需求动态的组装、分离系统。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）插件是别人开发的可以用到某主程序中的，只服务于该主程序，可重用性差。</li>
</ul>
</li>
</ul>
<h4 id="314面向agent风格">3.14、面向Agent风格</h4>
<p>认为事物的属性，特别是动态特性在很大程度上受到与其密切相关的人和环境的影响，将事务的主观与客观特征相结合抽象为系统的agent，作为系统的基本构成单位，通过agent之间的合作实现系统的整体目标。</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>（1）面向Agent的软件工程方法对于解决复杂问题是一种好的技术，特别是对于分布开放异构的软件环境。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）大多数结构中Agent自身缺乏社会性结构描述和与环境的交互。</li>
</ul>
</li>
</ul>
<h4 id="315面向方面软件架构风格">3.15、面向方面软件架构风格</h4>
<p>尽量分离“技术问题实现”和“业务问题实现”。允许开发者能够对横切关注点进行模块化设计。</p>
<ul>
<li><strong>优缺点分析</strong>
<ul>
<li>（1）可以定义交叉的关系，并将这些关系应用于跨模块的、彼此不同的对象模型。</li>
<li>（2）AOP同时还可以让我们层次化功能性而不是嵌入功能性，从而使代码由更好的可读性和易维护性。</li>
<li>（3）它会和面向对象编程可以很好地合作，互补。</li>
</ul>
</li>
</ul>
<h4 id="316面向服务架构风格">3.16、面向服务架构风格</h4>
<p><strong>服务请求者、服务提供者、服务注册中心</strong></p>
<p>具有基于标准、松散耦合、共享服务和粗粒度等优势，易于集成现有系统、具有标准化的架构、提升开发效率、降低开发维护复杂度。</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>（1）灵活性，根据需求变化，重新编排服务。</li>
<li>（2）对IT资产的复用。</li>
<li>（3）使企业的信息化建设真正以业务为核心。业务人员根据需求编排服务，而不必考虑技术细节。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）服务的划分很困难。</li>
<li>（2）服务的编排是否得当。</li>
<li>（3）如果选择的接口标准有问题，会带来系统额外开销和不稳定性。</li>
<li>（4）对IT硬件资产还谈不上复用。</li>
<li>（5）主流实现方式接口很多，很难统一。</li>
<li>（6）主流实现方式只局限于不带界面的服务的共享。</li>
</ul>
</li>
</ul>
<h4 id="317正交架构风格">3.17、正交架构风格</h4>
<p>是一种以垂直线索组件族为基础的层次化结构，其基本思想是把应用系统的结构按功能的正交相关性，垂直分割为若干个线索，线索又分为几个层次，每个线索由多个具有不同层次功能和不同抽象级别的组件构成。</p>
<ul>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>（1）由完成不同功能的n（n&gt;1）个线索（子系统）组成。</li>
<li>（2）系统具有m（m&gt;1）个不同抽象级别的层。</li>
<li>（3）线索之间是相互独立（正交）的。</li>
<li>（4）系统有一个公共驱动层（一般为最高层）和公共数据结构（一般为最底层）。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>（1）结构清晰，易于理解。</li>
<li>（2）易修改，可维护性强。</li>
<li>（3）可移植性强，重用粒度大。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>（1）在实际应用中，并不是所有软件系统都能完全正交化，或者有时完全正交化的成本太高。因此，在进行应用项目的软件架构设计是，必须反复权衡进一步正交化的额外开销与所得到的更好的性能之间的关系。</li>
</ul>
</li>
</ul>
<h4 id="318异构风格">3.18、异构风格</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>（1）可以实现遗留代码的重用。</li>
<li>（2）在某一单位中，规定了共享软件包和某些标准，但仍会存在解释和表示习惯上的不同。而异构风格可以解决这一问题。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）不同风格之间的兼容问题很难解决。</li>
</ul>
</li>
</ul>
<h4 id="319基于层次消息总线的架构风格">3.19、基于层次消息总线的架构风格</h4>
<p>基于层次消息总线、支持组件的分布和并发，组件之间通过消息总线进行通讯。</p>
<ul>
<li><strong>优点</strong>
<ul>
<li>（1）构件接口是一种基于消息的互联接口，可以较好的支持架构设计。降低了构件之间的耦合性，增强了构件之间的重用性。</li>
<li>（2）支持运行时的系统演化，主要体现在可动态增加和删除构件，动态改变构件所响应的消息以及消息过滤这三个方面。</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>（1）可重用要求高，可重用性差。</li>
</ul>
</li>
</ul>
<h4 id="320模型-视图-控制器风格">3.20、模型-视图-控制器风格</h4>
<p>MVC结构主要包括模型(封装问题的核心数据、逻辑关系和计算功能，提供处理问题的操作过程)、视图（提供交互界面）和控制器（处理用户与系统之间的交互）。</p>
<ul>
<li><strong>应用场景</strong>：用户交互程序的设计中</li>
<li><strong>优点</strong>：
<ul>
<li>（1）多个视图和一个模型相对应，便于维护。</li>
<li>（2）具有良好的移植性。</li>
<li>（3）当功能发生变化时，改变其中的一部分就能满足要求。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>（1）增加了系统设计和运行的复杂性。</li>
<li>（2）视图和控制器连接的过于紧密，妨碍了二者的独立重用。</li>
<li>（3）视图访问模型的效率比较低。</li>
<li>（4）频繁访问未变化的数据，也将降低系统性能。</li>
</ul>
</li>
</ul>
<h2 id="第六章软件架构与敏捷开发">第六章—软件架构与敏捷开发</h2>
<h3 id="1敏捷开发的基本理念">1、敏捷开发的基本理念。</h3>
<p>（1）强调个体和互动比强调过程和工具更好。</p>
<p>（2）强调获得可运行的软件比强调完成详尽的文档好。</p>
<p>（3）强调与客户合作比强调进行详细的合同谈判好。</p>
<p>（4）强调响应变化比强调遵循既定的计划好。</p>
<h3 id="2敏捷开发与架构设计的关系">2、敏捷开发与架构设计的关系。</h3>
<p>（1） 软件架构与敏捷开发的出发点是一致的。</p>
<ul>
<li>软件架构与敏捷开发都是一个权衡的过程：软件架构设计需要权衡涉众们的各种需求，在众多的解决方案中确定唯一的架构设计；敏捷开发是在软件开发过程混沌和大量开发管理活动加入的两个极端中做出的一种权衡。</li>
<li>软件架构与敏捷开发目的都是为了提高软件开发效率、提高软件质量、降低软件成本，将开发团队的价值最大化。</li>
</ul>
<p>（2）敏捷开发也需要重视软件架构。</p>
<ul>
<li>软件架构设计对于敏捷开发来说也是必要的。两者在软件开发实践中能够共同存在，且互相促进。</li>
</ul>
<p>（3）敏捷开发改变了软件架构的设计方式。</p>
<ul>
<li>敏捷开发将详细架构设计转移到Code编码阶段、重构阶段、单元测试阶段等。</li>
</ul>
<h3 id="3敏捷开发中如何改变了软件架构的设计方式">3、敏捷开发中如何改变了软件架构的设计方式？</h3>
<p>敏捷开发把传统软件开发前期的详细架构设计，分散到了整个敏捷开发软件过程中，以达到提高效率、减少风险的目的。</p>
<ul>
<li>
<p><strong>需求分析</strong></p>
<p>敏捷开发中的需求分析引入了架构设计的理念，分为初始阶段需求分析和迭代阶段需求分析。</p>
</li>
<li>
<p><strong>初始设计</strong></p>
<p>初始设计需要对软件系统的设计进行全局抽象层次上的考虑。包括系统的基本处理流程、系统的组织结构、模块划分、功能分配等</p>
</li>
<li>
<p><strong>迭代过程</strong></p>
<p>迭代设计、重构、确定架构、客户交流</p>
</li>
</ul>
<p>敏捷开发的思想在软件架构设计中最主要的体现就是团队设计和简单设计这两种设计理念。</p>
<ul>
<li><strong>团队设计</strong>
<ul>
<li>优点：其结论要比个人决策更加完整，避免个人遗漏，相对稳定、周密。</li>
<li>缺点：需要额外付出沟通成本、决策效率低、责任不明确。</li>
</ul>
</li>
<li><strong>简单设计</strong>
<ul>
<li>简单体现在两个方面：表达方式的简单和现实抽象的简单化。</li>
<li>简单设计可以降低开发成本、提升沟通效率、增强适应性和稳定性。</li>
</ul>
</li>
</ul>
<h2 id="第八章软件架构设计和实现">第八章—软件架构设计和实现</h2>
<h3 id="1成功的软件架构应具有的品质">1、成功的软件架构应具有的品质。</h3>
<p>（1）良好的模块化。</p>
<p>（2）适应功能需求的变化，适应技术的变化 。</p>
<p>（3）对系统的动态运行有良好的规划</p>
<p>（4）对数据的良好规划。</p>
<p>（5）明确、灵活的部署规划。</p>
<h3 id="2基于体系结构的软件设计方法">2、基于体系结构的软件设计方法。</h3>
<p>基于体系结构的软件设计（ architecture-based software design, ABSD）方法为软件系统的概念体系结构提供构造方法，概念体系结构描述了系统的主要设计元素及其关系。概念体系结构代表了在开发过程中做出的第一个选择，它是达到系统质量和业务目标的关键，为达到预定功能提供了基础。</p>
<p><strong>ABSD方法基础</strong></p>
<ul>
<li>功能分解：ABSD方法使用已有的基于模块的内聚和耦合技术；</li>
<li>通过选择体系结构风格来实现质量和业务需求。</li>
<li>软件模板的使用：利用一些软件系统的结构。</li>
</ul>
<p><strong>ABSD方法的步骤</strong></p>
<p>（1）功能分解：分解的目的是使每个组在体系结构内代表独立的元素。</p>
<p>（2）选择体系结构风格</p>
<p>（3）为风格分配功能</p>
<p>（4）细化模板</p>
<p>（5）功能校验</p>
<p>（6）创建并发视图</p>
<p>（7）创建配置视图</p>
<p>（8）验证质量场景</p>
<p>（9）验证约束</p>
<h3 id="3将软件架构的概念和原则引入软件需求阶段有什么好处不引入可能会引起什么问题">3、将软件架构的概念和原则引入软件需求阶段有什么好处？不引入可能会引起什么问题？</h3>
<ul>
<li>若把架构概念引入需求分析阶段，有助于保证需求规约、系统设计之间的可追踪性和一致性，有效保持软件质量。</li>
<li>将软件架构概念和原则引入需求分析，也可以让我们获得更有结构性和可重用的需求规约。</li>
<li>用传统的方法产生需求规约，不考虑软件架构概念和原则，则在软件架构设计阶段建立需求规约与架构的映射将相对困难。</li>
</ul>
<h3 id="4软件架构和软件需求是如何协同演化的">4、软件架构和软件需求是如何协同演化的？</h3>
<ul>
<li>软件需求和软件架构两者是相辅相成的关系，一方面软件需求影响软件架构设计，另一方面软件架构帮助需求分析的明确和细化。</li>
<li>需求与架构的互相影响可以看作一个螺旋的过程，也是一个双峰的过程。在一个反复的过程中，产生更详细的需求规约和设计规约，最终把交织在软件开发过程中的设计规约和需求规约分离开来。</li>
</ul>
<h3 id="5将软件架构映射到详细设计经常遇到什么问题如何解决">5、将软件架构映射到详细设计经常遇到什么问题？如何解决？</h3>
<p><strong>问题</strong>：</p>
<p>（1）缺失重要架构视图，片面强调功能需求。</p>
<p>（2）不够深入，架构设计方案过于笼统，基本还停留在概念性架构的层面，没有提供明确的技术蓝图。</p>
<p>（3）名不副实的分层架构，缺失层次之间的交互接口和交互机制，只进行职责划分。</p>
<p>（4）在某些方面过度设计。</p>
<p><strong>解决方法</strong>：</p>
<p>（1）对于缺失重要架构视图问题，可以针对遗漏的架构视图进行设计。</p>
<p>（2）对于不够深入问题，需要将设计决策细化到和技术相关的层面。</p>
<p>（3）对于名不副实的分层架构问题，需要步步深入，明确各层之间的交互接口和交互机制。</p>
<p>（4）虽然我们必须考虑到系统的扩展性，可维护性等，但切忌过度设计。</p>
<h3 id="6mda的基本思想过程应用mda的好处">6、MDA的基本思想、过程，应用MDA的好处。</h3>
<p>MDA——model driven architecture，基于模型驱动软件架构。</p>
<p><strong>基本思想：</strong></p>
<p>将软件系统分成模型和实现两部分：模型是对系统的描述，实现是利用特定技术在特定平台或环境中对模型的解释。模型仅仅负责对系统的描述，与实现技术无关。这是模型的实现技术无关性。</p>
<p><strong>过程：</strong></p>
<p>（1）用计算无关模型CIM 捕获需求；</p>
<p>（2）创建平台无关模型PIM；</p>
<p>（3）将PIM转化成为一个或多个平台特定模型PSM，并加入平台特定的规则和代码；</p>
<p>（4）将PSM 转化为代码等。</p>
<p><strong>好处：</strong></p>
<p>将模型与实现分离后，能够很好的适应技术易变性。由于实现往往高度依赖特定技术和特定平台，当技术发生迁移时，只需针对这种技术作相应的实现，编写相应的运行平台或变换工具。所以，能够比较好的应对实现技术发展带来的挑战。</p>
<h2 id="第十五章软件体系结构评估">第十五章—软件体系结构评估</h2>
<h3 id="1质量属性质量场景">1、质量属性、（质量）场景。</h3>
<p><strong>质量属性：</strong></p>
<p>（1）可修改性：度量软件系统变化的成本。</p>
<p>（2）可用性：是指软件能够正常运行的时间比例。</p>
<p>（3）性能：性能表示软件系统的响应速度或者由响应速度决定的其它度量。</p>
<p>（4）可测试性：软件系统在多大程度上容易被测试检查出缺陷。</p>
<p>（5）易用性：表明软件系统完成后用户的体验和效率。</p>
<p>（6）安全性：代表软件对未授权和非法操作的防卫能力。</p>
<p><strong>场景：</strong></p>
<ul>
<li>
<p>在进行体系结构评估时，一般首先要精确地得出具体的质量目标，并以之作为判定该体系结构优劣的标准。我们把为得出这些目标而采用的机制叫做场景。</p>
</li>
<li>
<p>场景是从风险承担者的角度对与系统的交互的简短描述。</p>
</li>
<li>
<p>在体系结构评估中，一般采用刺激、环境和响应三方面来对场景进行描述。</p>
</li>
</ul>
<h3 id="2体系结构权衡分析方法atam的相关概念敏感点权衡点质量效用树评估过程步骤质量效用树的构建优缺点">2、体系结构权衡分析方法（ATAM）的相关概念（敏感点、权衡点、质量效用树）、评估过程（步骤）、质量效用树的构建、优缺点。</h3>
<p><strong>ATAM-Architecture Tradeoff Analysis Method</strong></p>
<p><strong>（1）概念：</strong></p>
<ul>
<li>
<p>**敏感点：**敏感点是一个或者多个构件的特征，可以使设计师搞清楚实现质量目标时应该注意什么。</p>
</li>
<li>
<p>**权衡点：**权衡点是影响多个质量属性的特征；是多个质量属性的敏感点；权衡点需要进行权衡。</p>
</li>
<li>
<p>**质量效用树：**效用树为我们提供了一种直接而有效地将系统的业务驱动因素转换为具体的质量属性场景的机制，该步骤的输出结果是对具体质量属性需求（以场景形式实现）的优先级的确定。</p>
</li>
<li>
<p>**风险承担者、涉众、牵涉到的人：**体系结构设计师、开发人员、维护人员、集成人员、测试人员、标准专家、性能工程师</p>
</li>
</ul>
<p><strong>（2）ATAM评估步骤：</strong></p>
<p>​         ATAM主要部分包括4组，共9个步骤。</p>
<ul>
<li><strong>1）陈述，包括通过它进行的信息交流</strong>
<ul>
<li>①ATAM方法的陈述</li>
<li>②商业动机的陈述</li>
<li>③SA的陈述</li>
</ul>
</li>
<li><strong>2）调查与分析，包括对照体系结构方法评估关键</strong>
<ul>
<li>④确定体系结构方法</li>
<li>⑤生成质量效用树</li>
<li>⑥分析体系结构方法：</li>
</ul>
</li>
<li><strong>3）测试，包括对照所有相关人员的需求检验最新结果</strong>
<ul>
<li>⑦集体讨论并确定场景优先级</li>
<li>⑧分析体系结构方法</li>
</ul>
</li>
<li><strong>4）形成报告，包括陈述ATAM的结果</strong>
<ul>
<li>⑨结果的表述</li>
</ul>
</li>
</ul>
<p><strong>（3）质量效用树的构建</strong></p>
<ul>
<li>效用树中质量属性细化为场景</li>
<li>确定最重要的质量属性目标，并设置优先级</li>
<li>效用树设置优先级标准</li>
</ul>
<p><strong>（4）优缺点</strong></p>
<p><strong>优点</strong>：</p>
<ul>
<li>考虑了所有与系统相关的人员对质量的要求。</li>
<li>涉及到的基本活动包括确定应用领域的功能和软件体系结构之间的映射，设计用于体现待评估质量属性的场景以及分析软件体系结构对场景的支持程度。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>基于场景的评估方式是特定领域的，对一个领域适合的场景设计在另一领域未必适合。</li>
<li>实施者一方面需要有丰富的领域知识以对某质量需求设计出合理的场景，另一方面，必须对待评估的软件体系结构有一定的了解以判断是否支持场景描述的一系列活动。</li>
</ul>
<h2 id="软件架构相关课题">软件架构相关课题</h2>
<h3 id="1软件架构演化与维护">1、软件架构演化与维护</h3>
<p>软件架构演化就是为了维护软件架构自身的有用性。</p>
<p><strong>（1）对象演化 （2）消息演化（3）复合片段演化（4）约束演化</strong></p>
<p>针对软件架构的演化过程是否处于系统运行时期，可以将软件架构演化分为静态演化和动态演化。</p>
<ul>
<li>静态演化：发生在软件架构设计、实现和维护过程中，软件系统还未运行或者处于运行停止状态。</li>
<li>动态演化：发生在软件系统运行过程中。</li>
</ul>
<h3 id="2架构腐蚀">2、架构腐蚀</h3>
<p>软件架构腐蚀（software architecture erosion）是指预期软件架构或概念软件架构与实际软件架构之间的偏离。它意味着最终的实现并没有完全满足预定的计划或违背了系统的约束和规则。这种偏离更多的是源自日常的软件修改，而非人为的恶意。架构腐蚀会导致软件演化过程中出现工程质量的恶化。</p>
<p><strong>预防方法</strong>：</p>
<ul>
<li>腐蚀最小化</li>
<li>腐蚀预防</li>
<li>腐蚀修补</li>
</ul>
<h3 id="3架构技术债">3、架构技术债</h3>
<p>技术债是指开发人员为了加速软件开发，或是由于自身经验的缺乏，有意或无意的在应该采用最佳方案的时候进行了妥协，使用了短时期能加速软件开发的方案，从而在未来给自己带来额外的开发负担。</p>
<p><strong>分类：</strong></p>
<ul>
<li>代码债</li>
<li>设计债</li>
<li>测试债</li>
<li>文档债</li>
</ul>
<h3 id="4架构坏味道">4、架构坏味道</h3>
<ul>
<li>如果程序中某一段代码是不稳定的或者有一些潜在的问题，那么该段代码往往会包含一些明显的不太好的痕迹。我们称这些痕迹为代码坏味道。架构坏味道定义和代码坏味道类似，只是架构坏味道在系统粒度下出现的层次要高于代码坏味道。</li>
<li>架构坏味道是一种通常使用的，可以对系统生命周期特性产生消极影响的架构设计。它可能是由于在不适当的环境下应用了一个不适合的解决方案或者在错误的粒度层次下应用了某个设计抽象等产生的，会对系统的可理解性、可测试性、可扩展性以及可重用性等产生负面影响。</li>
<li>**典型的架构坏味道：**连接件嫉妒、过度分散的功能、模糊接口、无关的相邻连接件、砖关注过载、砖使用过载、砖循环依赖、未使用接口、重复的组件功能、组件嫉妒、连接件链。</li>
</ul>
<h3 id="5架构脆弱性">5、架构脆弱性</h3>
<ul>
<li>软件（系统）架构设计存在一些明显的或者隐含的缺陷，攻击者可以利用这些缺陷攻击系统，或者当受到某个或某些外部刺激时，系统发生性能下降、稳定性下降、可靠性下降、安全性下降等等。如果软件架构具备这类缺陷，我们认为该软件架构是脆弱的，也就是软件架构脆弱性。</li>
<li>软件架构脆弱性通常与软件架构的风格和模式有关，不同风格和模式的软件架构，脆弱性体现和特点有很大不同。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Leetcode 刷题笔记</title>
			<link>https://LeiBuDao.github.io/posts/leetcode/</link>
			<pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/leetcode/</guid>
			<description>1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。  示例 1：   输入：nums = [2,7,11,15], target = 9， 输出：[0,1]
  示例 2：   输入：nums = [3,2,4], target = 6， 输出：[1,2]
  示例 3：   输入：nums = [3,3], target = 6， 输出：[0,1]
  * 解法一 暴力法，二重循环  复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。  * 解法二 排序+双指针  思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。 复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。 为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。    class Solution {public:static bool cmp(const pair&amp;lt;int,int&amp;gt;a,const pair&amp;lt;int,int&amp;gt;b){return a.</description>
			<content type="html"><![CDATA[<h1 id="1两数之和"><strong>1.两数之和</strong></h1>
<h2 id="题目给定一个整数数组-nums和一个整数目标值-target请你在该数组中找出和为目标值-target的那两个整数并返回它们的数组下标">题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9，
输出：[0,1]</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums = [3,2,4], target = 6，
输出：[1,2]</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums = [3,3], target = 6，
输出：[0,1]</p>
</blockquote>
<hr>
<h2 id="-解法一">* <em>解法一</em></h2>
<h3 id="暴力法二重循环">暴力法，二重循环</h3>
<ul>
<li>复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。</li>
</ul>
<h2 id="-解法二">* <em>解法二</em></h2>
<h3 id="排序双指针">排序+双指针</h3>
<ul>
<li>思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。</li>
<li>复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。
为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){
        return a.first&lt;b.first;
    }
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;pair&lt;int,int&gt;&gt; vec;
        for(int i = 0; i &lt; nums.size(); i++){
            vec.push_back(make_pair(nums[i],i));
        }
        sort(vec.begin(),vec.end(),cmp);
        int i = 0,j = nums.size()-1;
        while(i&lt;j){
            if(vec[i].first+vec[j].first&gt;target) {
                j--;
            }
            else if(vec[i].first+vec[j].first&lt;target) {
                i++;
            }
            else if(vec[i].first+vec[j].first==target) { 
                return {vec[i].second,vec[j].second};
            }
        }
        return {};
    }
};
</code></pre>
<h2 id="-解法三">* <em>解法三</em></h2>
<h3 id="hash表">Hash表</h3>
<ul>
<li>思想：创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</li>
<li>复杂度：
<ul>
<li>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以O(1)地寻找 target - x。</li>
<li>空间复杂度：O(n)，其中 n 是数组中的元素数量,主要为哈希表的开销。</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashtable;
        for (int i = 0; i &lt; nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it-&gt;second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<h1 id="88合并两个有序数组"><strong>88.合并两个有序数组</strong></h1>
<h2 id="题目-给你两个按非递减顺序排列的整数数组nums1-和-nums2另有两个整数-m-和-n-分别表示-nums1-和-nums2-中的元素数目请你合并nums2-到-nums1-中使合并后的数组同样按非递减顺序排列"><em><strong>题目：</strong></em> 给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</h2>
<h2 id="注意--最终合并后数组不应由函数返回而是存储在数组-nums1-中为了应对这种情况nums1-的初始长度为-m--n其中前-m-个元素表示应合并的元素后-n-个元素为-0-应忽略nums2-的长度为-n-"><em><strong>注意：</strong></em>  最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3。<br>
输出：[1,2,2,3,5,6]<br>
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1], m = 1, nums2 = [], n = 0 。<br>
输出：[1]。<br>
解释：需要合并 [1] 和 [] 。合并结果是 [1] 。</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1 。<br>
输出：[1]  。<br>
解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
</blockquote>
<h2 id="-解法一-1">* <em>解法一</em></h2>
<h3 id="合并后直接排序">合并后直接排序</h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O((m+n)log(m+n))
排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)\log(m+n))</p>
</li>
<li>
<p>空间复杂度：O(log(m+n))。
排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(\log(m+n))O(log(m+n))。</p>
</li>
</ul>
</li>
</ul>
<h2 id="-解法二-1">* <em>解法二</em></h2>
<h3 id="双指针归并">双指针归并</h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O(m+n)。
指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。</p>
</li>
<li>
<p>空间复杂度：O(m+n)。
需要建立长度为 m+n 的中间数组 sorted。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = 0, p2 = 0;
        int sorted[m + n];
        int cur;
        while (p1 &lt; m || p2 &lt; n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] &lt; nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
};
</code></pre>
<h2 id="-解法三-1">* <em>解法三</em></h2>
<h3 id="逆向双指针">逆向双指针</h3>
<ul>
<li>算法思想： 通过题意所示，我们可以使用暴破，双指针+额外存储空间来完成该题，但是这两种做法的空间和时间复杂度至少都是 O(m + n) 。这个时候我们就要分析，为什么告诉我们 nums1.length &gt;= m + n，很明显就能猜出出题者的意图，那就是考查原地修改，将空间复杂度降低到 O(1)。因为这样不需要使用额外的数组空间了，我们完全可以把 nums2 也放入 nums1 中。原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择从后往前遍历！所以，我们总共需要创建三个指针，两个指针用于指向 nums1 和 nums2 的初始化元素数量的末位，也就是分别指向 m-1 和 n-1 的位置，还有一个指针，我们指向 nums1 数组末位即可。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 &gt;= 0 || p2 &gt;= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] &gt; nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
};
</code></pre>
]]></content>
		</item>
		
	</channel>
</rss>
