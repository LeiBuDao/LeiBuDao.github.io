<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Run</title>
		<link>https://LeiBuDao.github.io/posts/</link>
		<description>Recent content in Posts on Run</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 23 Dec 2021 10:55:47 +0800</lastBuildDate>
		<atom:link href="https://LeiBuDao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>软件体系结构期末复习</title>
			<link>https://LeiBuDao.github.io/posts/safinalexam/</link>
			<pubDate>Thu, 23 Dec 2021 10:55:47 +0800</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/safinalexam/</guid>
			<description>第二章 1、概述  组成派关注于软件本身，将软件架构看做组件和交互的集合。 决策派关注于架构中的实体(人)，将软件架构视为一系列重要设计决策的集合。  2、组成派定义 依据：软件架构主要反映系统由哪些部分组成，以及这些部分是如何组成的，强调系统的整体结构和配置。  （1）1992 —Dewane Perry &amp;amp; Alexander Wolf
软件架构 = {元素、组成、原理}
  架构元素：处理元素、数据元素、连接元素
  架构组成：
  加权的属性：约束架构的选择
  关系：约束架构元素的放置
    架构原理：捕获在选择架构风格、架构元素和架构形式的选择动机。
  （2）Mary Shaw &amp;amp; David Carlan
软件架构包括组件、连接件和约束三大要素。
 组件：可以是一组代码，也可以是独立的程序。 连接件：可以是过程调用、管道和消息等，用于表示组件间的相互关系。 约束：组件连接时的条件。  （3）2011年 ISO/IEC/IEEE标准
软件架构是某一系统的基本组织结构，其内容包括软件组件、组件间的联系、组件与其环境间的关系，以及指导上述内容设计与演化的原理。
3、决策派定义 依据：软件架构是软件设计的一部分，软件设计实际上是开发人员意志和决策在软件开发过程中的体现，强调设计决策，更加注重架构风格和模式选择。  4、参考定义框架 组件（Component）、连接件（Connector）、配置（Configuration）、端口（Port）、角色（Role）
 组件：具有某种功能的可重用的软件模块单元。 连接件：表示了组件之间的交互。 配置：表示了组件和连接件的拓扑逻辑和约束。 端口：组件的接口由一组端口组成，每个端口表示了组件和外部环境的交汇点。 角色：连接件的接口由一组角色组成，连接件的每个角色定义了该连接件表示的交互的参与者。  二元连接件有两个角色 有的连接件有多于两个的角色    第三章 至今没有一种建模方法能够满足软件架构建模的所有要求。</description>
			<content type="html"><![CDATA[<h2 id="第二章">第二章</h2>
<h3 id="1概述">1、概述</h3>
<ul>
<li>组成派关注于软件本身，将软件架构看做组件和交互的集合。</li>
<li>决策派关注于架构中的实体(人)，将软件架构视为一系列重要设计决策的集合。</li>
</ul>
<h3 id="2组成派定义">2、组成派定义</h3>
<pre><code>依据：软件架构主要反映系统由哪些部分组成，以及这些部分是如何组成的，强调系统的整体结构和配置。
</code></pre>
<p>（1）1992 —Dewane Perry &amp; Alexander Wolf</p>
<p>软件架构 = {元素、组成、原理}</p>
<ul>
<li>
<p>架构元素：处理元素、数据元素、连接元素</p>
</li>
<li>
<p>架构组成：</p>
<ul>
<li>
<p>加权的属性：约束架构的选择</p>
</li>
<li>
<p>关系：约束架构元素的放置</p>
</li>
</ul>
</li>
<li>
<p>架构原理：捕获在选择架构风格、架构元素和架构形式的选择动机。</p>
</li>
</ul>
<p>（2）Mary Shaw &amp; David Carlan</p>
<p>软件架构包括组件、连接件和约束三大要素。</p>
<ul>
<li>组件：可以是一组代码，也可以是独立的程序。</li>
<li>连接件：可以是过程调用、管道和消息等，用于表示组件间的相互关系。</li>
<li>约束：组件连接时的条件。</li>
</ul>
<p>（3）2011年 ISO/IEC/IEEE标准</p>
<p>软件架构是某一系统的基本组织结构，其内容包括软件组件、组件间的联系、组件与其环境间的关系，以及指导上述内容设计与演化的原理。</p>
<h3 id="3决策派定义">3、决策派定义</h3>
<pre><code>依据：软件架构是软件设计的一部分，软件设计实际上是开发人员意志和决策在软件开发过程中的体现，强调设计决策，更加注重架构风格和模式选择。
</code></pre>
<h3 id="4参考定义框架">4、参考定义框架</h3>
<p>组件（Component）、连接件（Connector）、配置（Configuration）、端口（Port）、角色（Role）</p>
<ul>
<li>组件：具有某种功能的可重用的软件模块单元。</li>
<li>连接件：表示了组件之间的交互。</li>
<li>配置：表示了组件和连接件的拓扑逻辑和约束。</li>
<li>端口：组件的接口由一组端口组成，每个端口表示了组件和外部环境的交汇点。</li>
<li>角色：连接件的接口由一组角色组成，连接件的每个角色定义了该连接件表示的交互的参与者。
<ul>
<li>二元连接件有两个角色</li>
<li>有的连接件有多于两个的角色</li>
</ul>
</li>
</ul>
<h2 id="第三章">第三章</h2>
<p><em><strong>至今没有一种建模方法能够满足软件架构建模的所有要求。</strong></em></p>
<h3 id="1软件架构的五类建模方法过程缺点">1、软件架构的五类建模方法（过程、缺点）。</h3>
<h4 id="基于非规范的图形表示的建模方法">①基于非规范的图形表示的建模方法</h4>
<ul>
<li>
<p>非正式图形表示：盒线图</p>
</li>
<li>
<p>正式图形表示：</p>
<ul>
<li>
<p>树形结构：</p>
<p>（1）是显示层次性软件架构的理想方法。</p>
<p>（2）难以处理复杂的问题。</p>
</li>
<li>
<p>树地图（TreeMap）</p>
<p>底层盒子往往用于表示方法，组合盒子往往用于表示类。</p>
<p>（1）是展示整个软件层次架构的有效方法。</p>
<p>（2）实质是一种空间填充方法。</p>
</li>
<li>
<p>改进的树地图</p>
</li>
<li>
<p>冰块图（Icicle Plot）</p>
<p>每一行代表树的一个层次，按照子节点的数量进行分割。</p>
<p>（1）有助于理解结构化的关系。</p>
<p>（2）对于大型系统的层次化架构，这种可视化技术的扩展性和导航性存在问题。</p>
</li>
<li>
<p>旭日图（SunBurst）</p>
<p>（1）具有较好的弹性：图中元素的角度和颜色。</p>
<p>（2）与树地图相比，更易学习且更令人舒适。</p>
</li>
<li>
<p>双曲图（Hyperbolic）</p>
<p>（1）双曲空间比欧几里得空间有更多的显示空间。</p>
</li>
</ul>
</li>
</ul>
<h4 id="基于uml的建模方法">②基于UML的建模方法</h4>
<pre><code>用例图、类图、状态图、协作图、序列图、活动图、包图、组件图、部署图、复合结构、交互概述图、时序图
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">架构元素</th>
<th style="text-align:center">UML模型组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组件</td>
<td style="text-align:center">分类器（如类、组件、节点、用例等）</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:center">接口</td>
</tr>
<tr>
<td style="text-align:center">关系（连接器）</td>
<td style="text-align:center">关系（如泛化、关联、依赖等）</td>
</tr>
<tr>
<td style="text-align:center">约束（规则）</td>
<td style="text-align:center">规则</td>
</tr>
</tbody>
</table>
<p>用UML建模的三种方法：</p>
<ul>
<li>（1）将UML看作是一种软件架构描述语言直接对架构建模。</li>
<li>（2）通过扩展机制约束UML的元模型以支持软件架构模型的需要。</li>
<li>（3）对UML的元模型进行扩充。</li>
</ul>
<h4 id="基于形式化的建模方法">③基于形式化的建模方法</h4>
<h4 id="基于uml形式化的方法">④基于UML形式化的方法</h4>
<pre><code>UML不是一种形式化的语言 
</code></pre>
<ul>
<li><strong>形式化与UML结合的建模过程：</strong></li>
</ul>
<p>需求分析 ——&gt; 需求文档规格说明 ——&gt; UML建模 ——&gt; 形式化描述 ——&gt; 程序编码 ——&gt; 测试变量（形式规范自动生成） ——&gt; 软件产品</p>
<p>（注意：前四步占全部工作量的60-70%）</p>
<h4 id="其他建模方法文本语言mda">⑤其他建模方法（文本语言、MDA）</h4>
<ul>
<li>
<p><strong>文本语言建模方法</strong></p>
<ul>
<li>
<p>文本语言建模是通过文本文件描绘架构，这些文本文件通常需要符合某些特殊的句法格式。</p>
</li>
<li>
<p>可用方法：语法高亮显示、文本的静态检查、自动补全、代码折叠</p>
</li>
<li>
<p>种类：XML文本建模方法、xADLite文本建模方法</p>
</li>
<li>
<p><strong>优势：</strong></p>
<p>（1）单个文档中描述整体架构，并且存在众多文本编辑器方便用户与文本文档的交互</p>
<p>（2）许多工具能够生成程序库来对使用该语言的文本文档进行句法分析和检查。</p>
<p>（3）许多编辑器附带额外的开发支持工具。</p>
</li>
<li>
<p><strong>缺点：</strong></p>
<p>（1）用文本语言建模方法表示类图形结构就不易理解。</p>
<p>（2）文本编辑器通常限于显示满屏的文本，很难以另外的方式组织文本。</p>
</li>
</ul>
</li>
<li>
<p><strong>MDA</strong></p>
<ul>
<li>MDA不是一个实现分布式系统的软件架构，而是一个模型技术进行软件开发的方法</li>
<li>MDA将模型区分为PIM和PSM
<ul>
<li>平台无关模型（PIM）：PIM是一个系统的形式化规范，它与具体的实现技术无关。</li>
<li>平台相关模型（PSM）：PSM基于某一具体目标平台的形式化规范。</li>
</ul>
</li>
<li>它的核心思想是抽象出与实现技术无关、完整描述业务功能的平台独立模型。</li>
</ul>
</li>
</ul>
<h3 id="241模型">2、“4+1”模型</h3>
<h4 id="1逻辑视图支持行为要求">（1）逻辑视图：支持行为要求。</h4>
<ul>
<li>描述系统各部分的抽象描述。用于建模系统的组成部分以及各组成部分之间的交互方式。</li>
<li>通常包括类图、对象图、状态图和协作图。</li>
</ul>
<h4 id="2过程视图解决并发和分发">（2）过程视图：解决并发和分发。</h4>
<ul>
<li>描述系统中的进程。 当 可视化系统中一定会发生的事情时，此视图特别有用。</li>
<li>该视图通常包含活动图、顺序图等。</li>
</ul>
<h4 id="3开发视图组织软件模块库子系统开发单元">（3）开发视图：组织软件模块，库，子系统，开发单元。</h4>
<ul>
<li>描述系统的各部分如何被组织为模块和组件。</li>
<li>该视图通常包含包图和组件图。</li>
<li>管理系统体系结构中的层非常有用。</li>
</ul>
<h4 id="4物理视图将其他元素映射到处理和通信节点">（4）物理视图：将其他元素映射到处理和通信节点。</h4>
<ul>
<li>
<p>描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体</p>
</li>
<li>
<p>该视图通常包含部署图，展示了抽象部分</p>
<p>如何映射到最终部署的系统中。</p>
</li>
</ul>
<h4 id="5用例视图将其他视图映射到重要的用例这些用例被称作场景上对体系结构加以说明">（5）用例视图：将其他视图映射到重要的用例（这些用例被称作场景）上对体系结构加以说明。</h4>
<ul>
<li>从外部世界的角度描述正在建模的系统的功能。</li>
<li>需要使用此视图来描述系统应该执行的操作。 所有其他视图都依靠用例视图（场景）来指导，这就是将模型称为4 + 1的原因。</li>
<li>该视图通常包含用例图，描述和概述图。</li>
</ul>
<h2 id="第四章">第四章</h2>
<h3 id="1什么是软件架构风格">1、什么是软件架构风格？</h3>
<h3 id="2使用架构风格的好处">2、使用架构风格的好处。</h3>
<h3 id="3经典体系结构风格的特点优缺点适用范围组件连接件约束">3、经典体系结构风格的特点、优缺点、适用范围。（组件、连接件、约束）</h3>
<h4 id="31管道过滤器风格">3.1、管道过滤器风格</h4>
<h4 id="32主程序子程序风格">3.2、主程序/子程序风格</h4>
<h4 id="33面向对象风格">3.3、面向对象风格</h4>
<h4 id="34层次化风格">3.4、层次化风格</h4>
<h4 id="35事件驱动风格">3.5、事件驱动风格</h4>
<h4 id="36解释器风格">3.6、解释器风格</h4>
<h4 id="37基于规则的系统风格">3.7、基于规则的系统风格</h4>
<h4 id="38仓库风格">3.8、仓库风格</h4>
<h4 id="39黑板系统风格">3.9、黑板系统风格</h4>
<h4 id="310c2风格">3.10、C2风格</h4>
<h4 id="311cs风格">3.11、C/S风格</h4>
<h4 id="312bs风格">3.12、B/S风格</h4>
<h4 id="313平台插件风格">3.13、平台/插件风格</h4>
<h4 id="314面向agent风格">3.14、面向Agent风格</h4>
<h4 id="315面向方面软件架构风格">3.15、面向方面软件架构风格</h4>
<h4 id="316面向服务架构风格">3.16、面向服务架构风格</h4>
<h4 id="317正交架构风格">3.17、正交架构风格</h4>
<h4 id="318异构风格">3.18、异构风格</h4>
<h4 id="319基于层次消息总线的架构风格">3.19、基于层次消息总线的架构风格</h4>
<h4 id="320模型-视图-控制器风格">3.20、模型-视图-控制器风格</h4>
<h2 id="第六章">第六章</h2>
<h3 id="1敏捷开发的基本理念">1、敏捷开发的基本理念。</h3>
<p>（1）强调个体和互动比强调过程和工具更好。</p>
<p>（2）强调获得可运行的软件比强调完成详尽的文档好。</p>
<p>（3）强调与客户合作比强调进行详细的合同谈判好。</p>
<p>（4）强调响应变化比强调遵循既定的计划好。</p>
<h3 id="2敏捷开发与架构设计的关系">2、敏捷开发与架构设计的关系。</h3>
<p>（1） 软件架构与敏捷开发的出发点是一致的。</p>
<ul>
<li>软件架构与敏捷开发都是一个权衡的过程：软件架构设计需要权衡涉众们的各种需求，在众多的解决方案中确定唯一的架构设计；敏捷开发是在软件开发过程混沌和大量开发管理活动加入的两个极端中做出的一种权衡。</li>
<li>软件架构与敏捷开发目的都是为了提高软件开发效率、提高软件质量、降低软件成本，将开发团队的价值最大化。</li>
</ul>
<p>（2）敏捷开发也需要重视软件架构。</p>
<ul>
<li>软件架构设计对于敏捷开发来说也是必要的。两者在软件开发实践中能够共同存在，且互相促进。</li>
</ul>
<p>（3）敏捷开发改变了软件架构的设计方式。</p>
<ul>
<li>敏捷开发将详细架构设计转移到Code编码阶段、重构阶段、单元测试阶段等。</li>
</ul>
<h3 id="3敏捷开发中如何改变了软件架构的设计方式">3、敏捷开发中如何改变了软件架构的设计方式？</h3>
<p>敏捷开发把传统软件开发前期的详细架构设计，分散到了整个敏捷开发软件过程中，以达到提高效率、减少风险的目的。</p>
<ul>
<li>
<p><strong>需求分析</strong></p>
<p>敏捷开发中的需求分析引入了架构设计的理念，分为初始阶段需求分析和迭代阶段需求分析。</p>
</li>
<li>
<p><strong>初始设计</strong></p>
<p>初始设计需要对软件系统的设计进行全局抽象层次上的考虑。包括系统的基本处理流程、系统的组织结构、模块划分、功能分配等</p>
</li>
<li>
<p><strong>迭代过程</strong></p>
<p>迭代设计、重构、确定架构、客户交流</p>
</li>
</ul>
<h2 id="第八章">第八章</h2>
<h3 id="1成功的软件架构应具有的品质">1、成功的软件架构应具有的品质。</h3>
<p>（1）良好的模块化。</p>
<p>（2）适应功能需求的变化，适应技术的变化 。</p>
<p>（3）对系统的动态运行有良好的规划</p>
<p>（4）对数据的良好规划。</p>
<p>（5）明确、灵活的部署规划。</p>
<h3 id="2基于体系结构的软件设计方法">2、基于体系结构的软件设计方法。</h3>
<p>基 于 体 系 结 构 的 软 件 设 计 （ architecture-based software design, ABSD）方法为软件系统的概念体系结构提供构造方法，概念体系结构描述了系统的主要设计元素及其关系。</p>
<p><strong>ABSD方法基础</strong></p>
<ul>
<li>功能分解：ABSD方法使用已有的基于模块的内聚和耦合技术；</li>
<li>通过选择体系结构风格来实现质量和业务需求。</li>
<li>软件模板的使用：利用一些软件系统的结构。</li>
</ul>
<p><strong>ABSD方法的步骤</strong></p>
<p>（1）功能分解：分解的目的是使每个组在体系结构内代表独立的元素。</p>
<p>（2）选择体系结构风格</p>
<p>（3）为风格分配功能</p>
<p>（4）细化模板</p>
<p>（5）功能校验</p>
<p>（6）创建并发视图</p>
<p>（7）创建配置视图</p>
<p>（8）验证质量场景</p>
<p>（9）验证约束</p>
<h3 id="3将软件架构的概念和原则引入软件需求阶段有什么好处不引入可能会引起什么问题">3、将软件架构的概念和原则引入软件需求阶段有什么好处？不引入可能会引起什么问题？</h3>
<ul>
<li>若把架构概念引入需求分析阶段，有助于保证需求规约、系统设计之间的可追踪性和一致性，有效保持软件质量。</li>
<li>将软件架构概念和原则引入需求分析，也可以让我们获得更有结构性和可重用的需求规约。</li>
<li>用传统的方法产生需求规约，不考虑软件架构概念和原则，则在软件架构设计阶段建立需求规约与架构的映射将相对困难。</li>
</ul>
<h3 id="4软件架构和软件需求是如何协同演化的">4、软件架构和软件需求是如何协同演化的？</h3>
<h3 id="5将软件架构映射到详细设计经常遇到什么问题如何解决">5、将软件架构映射到详细设计经常遇到什么问题？如何解决？</h3>
<p><strong>问题</strong></p>
<p>（1）缺失重要架构视图，片面强调功能需求。</p>
<p>（2）不够深入，架构设计方案过于笼统，基本还停留在概念性架构的层面，没有提供明确的技术蓝图。</p>
<p>（3）名不副实的分层架构，缺失层次之间的交互接口和交互机制，只进行职责划分。</p>
<p>（4）在某些方面过度设计。</p>
<p><strong>解决方法</strong></p>
<p>（1）对于缺失重要架构视图问题，可以针对遗漏的架构视图进行设计。</p>
<p>（2）对于不够深入问题，需要将设计决策细化到和技术相关的层面。</p>
<p>（3）对于名不副实的分层架构问题，需要步步深入，明确各层之间的交互接口和交互机制。</p>
<p>（4）虽然我们必须考虑到系统的扩展性，可维护性等，但切忌过度设计。</p>
<h3 id="6mda的基本思想过程应用mda的好处">6、MDA的基本思想、过程，应用MDA的好处。</h3>
<p><strong>基本思想</strong></p>
<p>将软件系统分成模型和实现两部分：模型是对系统的描述，实现是利用特定技术在特定平台或环境中对模型的解释。模型仅仅负责对系统的描述，与实现技术无关。这是模型的实现技术无关性。</p>
<p><strong>过程</strong></p>
<p>（1）用计算无关模型CIM 捕获需求；</p>
<p>（2）创建平台无关模型PIM；</p>
<p>（3）将PIM转化成为一个或多个平台特定模型PSM，并加入平台特定的规则和代码；</p>
<p>（4）将PSM 转化为代码等。</p>
<p><strong>好处</strong></p>
<p>将模型与实现分离后，能够很好的适应技术易变性。由于实现往往高度依赖特定技术和特定平台，当技术发生迁移时，只需针对这种技术作相应的实现，编写相应的运行平台或变换工具。所以，能够比较好的应对实现技术发展带来的挑战。</p>
<h2 id="第十五章">第十五章</h2>
<h3 id="1质量属性质量场景">1、质量属性、（质量）场景。</h3>
<p><strong>质量属性</strong></p>
<p>（1）可修改性：度量软件系统变化的成本。</p>
<p>（2）可用性：是指软件能够正常运行的时间比例。</p>
<p>（3）性能：性能表征软件系统的响应速度或者由响应速度决定的其它度量。</p>
<p>（4）可测试性：软件系统在多大程度上容易被测试检查出缺陷。</p>
<p>（5）易用性：表明软件系统完成后用户的体验和效率。</p>
<p>（6）安全性：代表软件对未授权和非法操作的防卫能力。</p>
<p><strong>场景</strong></p>
<ul>
<li>
<p>在进行体系结构评估时，一般首先要精确地得出具体的质量目标，并以之作为判定该体系结构优劣的标准。我们把为得出这些目标而采用的机制劣的标准。我们把为得出这些目标而采用的机制叫做场景。</p>
</li>
<li>
<p>场景是从风险承担者的角度对与系统的交互的简短描述。</p>
</li>
<li>
<p>在体系结构评估中，一般采用刺激、环境和响应三方面来对场景进行描述。</p>
</li>
</ul>
<h3 id="2体系结构权衡分析方法atam的相关">2、体系结构权衡分析方法（ATAM）的相关。</h3>
<h3 id="3概念敏感点权衡点质量效用树评估过程步骤质量效用树的构建优缺点">3、概念（敏感点、权衡点、质量效用树）、评估过程（步骤）、质量效用树的构建、优缺点。</h3>
<h2 id="软件架构相关课题">软件架构相关课题</h2>
<h3 id="1软件架构演化与维护">1、软件架构演化与维护</h3>
<h3 id="2架构腐蚀">2、架构腐蚀</h3>
<p>软件架构腐蚀（software architecture erosion）是指预期软件架构或概念软件架构与实际软件架构之间的偏离。它意味着最终的实现并没有完全满足预定的计划或违背了系统的约束和规则。这种偏离更多的是源自日常的软件修改，而非人为的恶意。架构腐蚀会导致软件演化过程中出现工程质量的恶化。</p>
<p><strong>预防方法</strong>：</p>
<ul>
<li>腐蚀最小化</li>
<li>腐蚀预防</li>
<li>腐蚀修补</li>
</ul>
<h3 id="3架构技术债">3、架构技术债</h3>
<h3 id="4架构坏味道">4、架构坏味道</h3>
<h3 id="5架构脆弱性">5、架构脆弱性</h3>
<ul>
<li>通常情况下，我们认为软件脆弱性是导致破坏系统安全策略的系统安全规范、系统设计、实现和内部控制等方面的弱点。</li>
<li>在软件开发过程中，软件脆弱性包含软件基础模型的脆弱性、软件架构设计的脆弱性、软件模块设计的脆弱性、软件接口设计的脆弱性、软件界面设计的脆弱性、数据库设计的脆弱性、架构模式和设计模式的脆弱性以及实现的脆弱性等等。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Leetcode 刷题笔记(最后更新-2021/12/5)</title>
			<link>https://LeiBuDao.github.io/posts/leetcode/</link>
			<pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
			
			<guid>https://LeiBuDao.github.io/posts/leetcode/</guid>
			<description>1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。  示例 1：   输入：nums = [2,7,11,15], target = 9， 输出：[0,1]
  示例 2：   输入：nums = [3,2,4], target = 6， 输出：[1,2]
  示例 3：   输入：nums = [3,3], target = 6， 输出：[0,1]
  * 解法一 暴力法，二重循环  复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。  * 解法二 排序+双指针  思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。 复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。 为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。    class Solution {public:static bool cmp(const pair&amp;lt;int,int&amp;gt;a,const pair&amp;lt;int,int&amp;gt;b){return a.</description>
			<content type="html"><![CDATA[<h1 id="1两数之和"><strong>1.两数之和</strong></h1>
<h2 id="题目给定一个整数数组-nums和一个整数目标值-target请你在该数组中找出和为目标值-target的那两个整数并返回它们的数组下标">题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9，
输出：[0,1]</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums = [3,2,4], target = 6，
输出：[1,2]</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums = [3,3], target = 6，
输出：[0,1]</p>
</blockquote>
<hr>
<h2 id="-解法一">* <em>解法一</em></h2>
<h3 id="暴力法二重循环">暴力法，二重循环</h3>
<ul>
<li>复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。</li>
</ul>
<h2 id="-解法二">* <em>解法二</em></h2>
<h3 id="排序双指针">排序+双指针</h3>
<ul>
<li>思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。</li>
<li>复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。
为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){
        return a.first&lt;b.first;
    }
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;pair&lt;int,int&gt;&gt; vec;
        for(int i = 0; i &lt; nums.size(); i++){
            vec.push_back(make_pair(nums[i],i));
        }
        sort(vec.begin(),vec.end(),cmp);
        int i = 0,j = nums.size()-1;
        while(i&lt;j){
            if(vec[i].first+vec[j].first&gt;target) {
                j--;
            }
            else if(vec[i].first+vec[j].first&lt;target) {
                i++;
            }
            else if(vec[i].first+vec[j].first==target) { 
                return {vec[i].second,vec[j].second};
            }
        }
        return {};
    }
};
</code></pre>
<h2 id="-解法三">* <em>解法三</em></h2>
<h3 id="hash表">Hash表</h3>
<ul>
<li>思想：创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</li>
<li>复杂度：
<ul>
<li>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以O(1)地寻找 target - x。</li>
<li>空间复杂度：O(n)，其中 n 是数组中的元素数量,主要为哈希表的开销。</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashtable;
        for (int i = 0; i &lt; nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it-&gt;second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<h1 id="88合并两个有序数组"><strong>88.合并两个有序数组</strong></h1>
<h2 id="题目-给你两个按非递减顺序排列的整数数组nums1-和-nums2另有两个整数-m-和-n-分别表示-nums1-和-nums2-中的元素数目请你合并nums2-到-nums1-中使合并后的数组同样按非递减顺序排列"><em><strong>题目：</strong></em> 给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</h2>
<h2 id="注意--最终合并后数组不应由函数返回而是存储在数组-nums1-中为了应对这种情况nums1-的初始长度为-m--n其中前-m-个元素表示应合并的元素后-n-个元素为-0-应忽略nums2-的长度为-n-"><em><strong>注意：</strong></em>  最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3。<br>
输出：[1,2,2,3,5,6]<br>
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1], m = 1, nums2 = [], n = 0 。<br>
输出：[1]。<br>
解释：需要合并 [1] 和 [] 。合并结果是 [1] 。</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1 。<br>
输出：[1]  。<br>
解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
</blockquote>
<h2 id="-解法一-1">* <em>解法一</em></h2>
<h3 id="合并后直接排序">合并后直接排序</h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O((m+n)log(m+n))
排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)\log(m+n))</p>
</li>
<li>
<p>空间复杂度：O(log(m+n))。
排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(\log(m+n))O(log(m+n))。</p>
</li>
</ul>
</li>
</ul>
<h2 id="-解法二-1">* <em>解法二</em></h2>
<h3 id="双指针归并">双指针归并</h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O(m+n)。
指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。</p>
</li>
<li>
<p>空间复杂度：O(m+n)。
需要建立长度为 m+n 的中间数组 sorted。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = 0, p2 = 0;
        int sorted[m + n];
        int cur;
        while (p1 &lt; m || p2 &lt; n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] &lt; nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
};
</code></pre>
<h2 id="-解法三-1">* <em>解法三</em></h2>
<h3 id="逆向双指针">逆向双指针</h3>
<ul>
<li>算法思想： 通过题意所示，我们可以使用暴破，双指针+额外存储空间来完成该题，但是这两种做法的空间和时间复杂度至少都是 O(m + n) 。这个时候我们就要分析，为什么告诉我们 nums1.length &gt;= m + n，很明显就能猜出出题者的意图，那就是考查原地修改，将空间复杂度降低到 O(1)。因为这样不需要使用额外的数组空间了，我们完全可以把 nums2 也放入 nums1 中。原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择从后往前遍历！所以，我们总共需要创建三个指针，两个指针用于指向 nums1 和 nums2 的初始化元素数量的末位，也就是分别指向 m-1 和 n-1 的位置，还有一个指针，我们指向 nums1 数组末位即可。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 &gt;= 0 || p2 &gt;= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] &gt; nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
};
</code></pre>
]]></content>
		</item>
		
	</channel>
</rss>
