<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="111214">
	<meta name="msapplication-TileColor" content="111214">
<meta itemprop="name" content="Promise学习笔记">
<meta itemprop="description" content="#目录 [TOC]
一、Promise的理解与使用 1、概念:
​	Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。
Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败
​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果
Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await
2、特点:
​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。
3、缺点:
​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。
​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
1、Promise是什么? Ⅰ-理解 抽象表达: ​	1) Promise 是一门新的技术(ES6 规范)
​	2)Promise 是 JS 中进行异步编程的新解决方案
​	备注：旧方案是单纯使用回调函数
具体表达: 从语法上来说: Promise 是一个构造函数
从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值
Ⅱ-promise 的状态 a) promise 的状态 实例对象中的一个属性 『PromiseState』
pending 未决定的 resolved / fullfilled 成功 rejected 失败 b) promise 的状态改变 pending 变为 resolved"><meta itemprop="datePublished" content="2022-03-12T13:38:13+08:00" />
<meta itemprop="dateModified" content="2022-03-12T13:38:13+08:00" />
<meta itemprop="wordCount" content="5751">
<meta itemprop="keywords" content="front-end," /><meta property="og:title" content="Promise学习笔记" />
<meta property="og:description" content="#目录 [TOC]
一、Promise的理解与使用 1、概念:
​	Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。
Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败
​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果
Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await
2、特点:
​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。
3、缺点:
​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。
​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
1、Promise是什么? Ⅰ-理解 抽象表达: ​	1) Promise 是一门新的技术(ES6 规范)
​	2)Promise 是 JS 中进行异步编程的新解决方案
​	备注：旧方案是单纯使用回调函数
具体表达: 从语法上来说: Promise 是一个构造函数
从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值
Ⅱ-promise 的状态 a) promise 的状态 实例对象中的一个属性 『PromiseState』
pending 未决定的 resolved / fullfilled 成功 rejected 失败 b) promise 的状态改变 pending 变为 resolved" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://LeiBuDao.github.io/posts/promise_study/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-12T13:38:13+08:00" />
<meta property="article:modified_time" content="2022-03-12T13:38:13+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Promise学习笔记"/>
<meta name="twitter:description" content="#目录 [TOC]
一、Promise的理解与使用 1、概念:
​	Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。
Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败
​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果
Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await
2、特点:
​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。
3、缺点:
​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。
​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
1、Promise是什么? Ⅰ-理解 抽象表达: ​	1) Promise 是一门新的技术(ES6 规范)
​	2)Promise 是 JS 中进行异步编程的新解决方案
​	备注：旧方案是单纯使用回调函数
具体表达: 从语法上来说: Promise 是一个构造函数
从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值
Ⅱ-promise 的状态 a) promise 的状态 实例对象中的一个属性 『PromiseState』
pending 未决定的 resolved / fullfilled 成功 rejected 失败 b) promise 的状态改变 pending 变为 resolved"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Promise学习笔记</title>
	<link rel="stylesheet" href="https://LeiBuDao.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">


</head>

<body id="page">
	
<header id="site-header" class="animated slideInUp">
	<div class="hdr-wrapper section-inner">
		<div class="hdr-left">
			<div class="site-branding">
				<a href="https://LeiBuDao.github.io/">Run</a>
			</div>
			<nav class="site-nav hide-in-mobile">
				
				<a href="https://LeiBuDao.github.io/about-myblog/">About</a>
				<a href="https://LeiBuDao.github.io/posts/">Blogs</a>
				<a href="https://LeiBuDao.github.io/project/">Project</a>
				<a href="https://LeiBuDao.github.io/contact-me/">Contact Me</a>

			</nav>
		</div>
		<div class="hdr-right hdr-icons">
			<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg
					xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-list">
					<line x1="8" y1="6" x2="21" y2="6"></line>
					<line x1="8" y1="12" x2="21" y2="12"></line>
					<line x1="8" y1="18" x2="21" y2="18"></line>
					<line x1="3" y1="6" x2="3" y2="6"></line>
					<line x1="3" y1="12" x2="3" y2="12"></line>
					<line x1="3" y1="18" x2="3" y2="18"></line>
				</svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/LeiBuDao" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg></a><a href="https://web.telegram.org" target="_blank" rel="noopener me" title="Telegram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M21.198 2.433a2.242 2.242 0 0 0-1.022.215l-8.609 3.33c-2.068.8-4.133 1.598-5.724 2.21a405.15 405.15 0 0 1-2.849 1.09c-.42.147-.99.332-1.473.901-.728.968.193 1.798.919 2.286 1.61.516 3.275 1.009 4.654 1.472.509 1.793.997 3.592 1.48 5.388.16.36.506.494.864.498l-.002.018s.281.028.555-.038a2.1 2.1 0 0 0 .933-.517c.345-.324 1.28-1.244 1.811-1.764l3.999 2.952.032.018s.442.311 1.09.355c.324.022.75-.04 1.116-.308.37-.27.613-.702.728-1.196.342-1.492 2.61-12.285 2.997-14.072l-.01.042c.27-1.006.17-1.928-.455-2.474a1.654 1.654 0 0 0-1.034-.407z" />
</svg></a><a href="https://instagram.com/" target="_blank" rel="noopener me" title="Instagram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
    <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
    <line x1="17.5" y1="6.5" x2="17.5" y2="6.5"></line>
</svg></a><a href="https://space.bilibili.com/438672729" target="_blank" rel="noopener me" title="Bilibili"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24"
    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg"
					width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
					stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
					<line x1="3" y1="12" x2="21" y2="12"></line>
					<line x1="3" y1="6" x2="21" y2="6"></line>
					<line x1="3" y1="18" x2="21" y2="18"></line>
				</svg></button>
		</div>
	</div>

</header>
<div id="mobile-menu" class="animated fast">
	<ul>
		<li><a href="https://LeiBuDao.github.io/about-myblog/">About</a></li>
		<li><a href="https://LeiBuDao.github.io/posts/">Blogs</a></li>
		<li><a href="https://LeiBuDao.github.io/project/">Project</a></li>
		<li><a href="https://LeiBuDao.github.io/contact-me/">Contact Me</a></li>
	</ul>
</div>

<main class="site-main section-inner animated fadeIn faster">
	<article class="thin">
		<header class="post-header">
			<div class="post-meta"><span>Mar 12, 2022</span></div>
			<h1>Promise学习笔记</h1>
		</header>
		<div class="content">
			<h1 id="目录">#目录<a href="#目录" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<blockquote>
<p>[TOC]</p>
</blockquote>
<h1 id="一promise的理解与使用">一、Promise的理解与使用<a href="#一promise的理解与使用" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<blockquote>
<p>1、概念:</p>
<p>​	Promise是<code>异步编程的一种解决方案</code>，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>通俗讲，<code>Promise是一个许诺、承诺</code>,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。</p>
<ul>
<li>Pending  正在做。。。</li>
<li>Resolved 完成这个承诺</li>
<li>Rejected 这个承诺没有完成，失败了</li>
</ul>
<p>​	Promise 用来预定一个不一定能完成的任务，要么成功，要么失败</p>
<p>​	在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果</p>
<p>Promise 是异步编程的一种解决方案，<code>主要用来解决回调地狱的问题，可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p>
<p>2、特点:</p>
<p>​	(1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>​	(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p>
<p>3、缺点:</p>
<p>​	(1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。</p>
<p>​	(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p>
<p>​	(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
</blockquote>
<hr>
<h2 id="1promise是什么">1、Promise是什么?<a href="#1promise是什么" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h4 id="-理解">Ⅰ-理解<a href="#-理解" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<ol>
<li>抽象表达:</li>
</ol>
<p>​	1) Promise 是一门新的技术(ES6 规范)</p>
<p>​	2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案</p>
<p>​		备注：旧方案是单纯使用回调函数</p>
<ol start="2">
<li>具体表达:</li>
</ol>
<ol>
<li>
<p>从语法上来说: Promise 是一个<code>构造函数</code></p>
</li>
<li>
<p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p>
</li>
</ol>
</blockquote>
<h4 id="-promise-的状态">Ⅱ-promise 的状态<a href="#-promise-的状态" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<h5 id="a-promise-的状态">a) promise 的状态<a href="#a-promise-的状态" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>实例对象中的一个属性 『PromiseState』</p>
<ul>
<li>pending  未决定的</li>
<li>resolved / fullfilled  成功</li>
<li>rejected  失败</li>
</ul>
</blockquote>
<h5 id="b-promise-的状态改变">b) promise 的状态改变<a href="#b-promise-的状态改变" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<ol>
<li>
<p>pending 变为 resolved</p>
</li>
<li>
<p>pending 变为 rejected</p>
</li>
</ol>
<p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次；</p>
<p>​			无论变为成功还是失败, 都会有一个结果数据 ；</p>
<p>​			成功的结果数据一般称为 value, 失败的结果数据一般称为 reason。</p>
</blockquote>
<h4 id="-promise的基本流程">Ⅲ-promise的基本流程<a href="#-promise的基本流程" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_promise%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Promise系统学习_promise工作流程"></p>
</blockquote>
<h4 id="-promise的基本使用">Ⅳ-promise的基本使用<a href="#-promise的基本使用" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<h6 id="1使用-promise-封装基于定时器的异步">1.使用 promise 封装基于定时器的异步<a href="#1使用-promise-封装基于定时器的异步" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">script</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">doDelay</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 创建 promise 对象(pending 状态), 指定执行器函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 2. 在执行器函数中启动异步任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;启动异步任务&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;延迟任务开始执行...&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="kr">const</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="c1">// 假设: 时间为奇数代表成功, 为偶数代表失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">time</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 成功了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 3.1. 如果成功了, 调用 resolve()并传入成功的 value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功的数据 &#39;</span> <span class="o">+</span> <span class="nx">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;失败的数据 &#39;</span> <span class="o">+</span> <span class="nx">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span> <span class="nx">time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doDelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="c1">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">// 成功的回调函数 onResolved, 得到成功的 vlaue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功的 value: &#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="c1">// 失败的回调函数 onRejected, 得到失败的 reason
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败的 reason: &#39;</span><span class="p">,</span> <span class="nx">reason</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span></code></pre></div><h6 id="2使用-promise-封装-ajax-异步请求">2.使用 promise 封装 ajax 异步请求<a href="#2使用-promise-封装-ajax-异步请求" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 封装一个函数 sendAJAX 发送 GET AJAX 请求
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 参数   URL
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 返回结果 Promise 对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">sendAJAX</span><span class="p">(</span><span class="nx">url</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kr">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//处理结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//判断成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//成功的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nx">resolve</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">reject</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sendAJAX</span><span class="p">(</span><span class="s1">&#39;https://api.apiopen.top/getJok&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span></code></pre></div><h6 id="3fs模块使用promise">3.fs模块使用Promise<a href="#3fs模块使用promise" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//回调函数 形式----------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 如果出错 则抛出错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>  <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="c1">//输出文件内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//Promise 形式-----------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 封装一个函数 mineReadFile 读取文件内容
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 参数:  path  文件路径
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 返回:  promise 对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mineReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//读取文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">).</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span><span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//输出文件内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">reason</span><span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><h6 id="4异常穿透">4.异常穿透<a href="#4异常穿透" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<blockquote>
<p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p>
<p>在每个.then()中我可以将数据再次传出给下一个then()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./11.txt&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span><span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span><span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span><span class="s2">&#34;2222222&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;这是catch的&#34;</span><span class="p">))</span>
</span></span></code></pre></div><h6 id="5utilpromisify方法">5.<code>util.promisify方法</code><a href="#5utilpromisify方法" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<blockquote>
<p>可以将函数直接变成promise的封装方式,不用再去手动封装</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//引入 util 模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//引入 fs 模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//返回一个新的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">mineReadFile</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">promisify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">mineReadFile</span><span class="p">(</span><span class="s1">&#39;./resource/content.txt&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><hr>
<h2 id="2为什么要用promise">2、为什么要用Promise?<a href="#2为什么要用promise" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="-指定回调函数的方式更加灵活">Ⅰ-指定回调函数的方式更加灵活<a href="#-指定回调函数的方式更加灵活" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>旧的: 必须在启动异步任务前指定</li>
<li>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定多个)</li>
</ol>
</blockquote>
<h3 id="-支持链式调用-可以解决回调地狱问题">Ⅱ-支持链式调用, 可以解决回调地狱问题<a href="#-支持链式调用-可以解决回调地狱问题" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<h5 id="1什么是回调地狱">1、什么是回调地狱<a href="#1什么是回调地狱" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p>
</blockquote>
<h5 id="2回调地狱的缺点">2、回调地狱的缺点?<a href="#2回调地狱的缺点" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>不便于阅读 不便于异常处理</p>
</blockquote>
<h5 id="3解决方案">3、解决方案?<a href="#3解决方案" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>promise <code>链式调用</code>,</p>
<p>用来解决回调地狱问题，但是<code>只是简单的改变格式</code>，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">finalResult</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got the final result: &#39;</span> <span class="o">+</span> <span class="nx">finalResult</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">failureCallback</span><span class="p">)</span>
</span></span></code></pre></div></blockquote>
<h5 id="4终极解决方案">4、终极解决方案?<a href="#4终极解决方案" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>promise +async/await</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">request</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">     <span class="kr">const</span> <span class="nx">newResult</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="kr">const</span> <span class="nx">finalResult</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got the final result: &#39;</span> <span class="o">+</span> <span class="nx">finalResult</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">failureCallback</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></blockquote>
<hr>
<h2 id="3promise中的常用-api-概述">3、Promise中的常用 API 概述<a href="#3promise中的常用-api-概述" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p>
</blockquote>
<h4 id="--promise-构造函数-promise-excutor">Ⅰ- Promise 构造函数: Promise (excutor)<a href="#--promise-构造函数-promise-excutor" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) <code>executor</code> 函数: 执行器 (resolve, reject) =&gt; {}</p>
<p>(2) <code>resolve</code> 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p>
<p>(3) <code>reject</code> 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p>
<p>说明: <code>executor</code> 会在 Promise 内部立即<code>同步调用</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p>
</blockquote>
<h4 id="-promiseprototypethen-方法-onresolved-onrejected-">Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt;<a href="#-promiseprototypethen-方法-onresolved-onrejected-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) <code>onResolved</code> 函数: 成功的回调函数 (value) =&gt; {}</p>
<p>(2) <code>onRejected</code> 函数: 失败的回调函数 (reason) =&gt; {}</p>
<p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p>
</blockquote>
<h4 id="-promiseprototypecatch-方法-onrejected-">Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt;<a href="#-promiseprototypecatch-方法-onrejected-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p>
<p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
<p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中</p>
</blockquote>
<h4 id="-promiseresolve-方法-value-">Ⅳ-Promise.resolve 方法: (value) =&gt;<a href="#-promiseresolve-方法-value-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>value</code>: 成功的数据或 promise 对象</p>
<p>说明: 返回一个成功/失败的 promise 对象,直接改变promise状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">521</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//如果传入的参数为 非Promise类型的对象, 则返回的结果为成功的Promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//如果传入的参数为 Promise 对象, 返回的结果为传入的Promise对象的返回结果，返回的值为传入的Promise对象的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// resolve(&#39;OK&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// console.log(p2);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div></blockquote>
<h4 id="-promisereject-方法-reason-">Ⅴ-Promise.reject 方法: (reason) =&gt;<a href="#-promisereject-方法-reason-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>reason</code>: 失败的原因</p>
<p>说明: 返回一个失败的 promise 对象,直接改变promise状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">521</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;iloveyou&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//如果传入的参数为 非Promise类型的对象, 则返回的结果为失败的promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1">//如果传入的参数为 Promise 对象, 返回的结果为&#34;rejected&#34;，且失败的值为传入的promise参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p3</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h4 id="-promiseall-方法-promises-">Ⅵ-Promise.all 方法: (promises) =&gt;<a href="#-promiseall-方法-promises-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>promises</code>: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, 只有所有的promise<strong>都成功才成功</strong>, 只要有一个失败了就直接失败。成功的结果为所有Promise对象结果组成的数组，而失败的结果为第一个[根据传入参数的顺序]失败的对象的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;错误错误错误&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;也是成功&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h4 id="-promiserace-方法-promises-">Ⅶ-Promise.race 方法: (promises) =&gt;<a href="#-promiserace-方法-promises-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>promises</code>: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, <strong>第一个完成</strong>的 promise 的结果状态就是最终的结果状态,</p>
<p>如p1延时,开启了异步,内部正常是同步进行,所以<strong>p2&gt;p3&gt;p1</strong>,结果是<strong>P2</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<hr>
<h2 id="4promise的几个关键问题">4、Promise的几个关键问题<a href="#4promise的几个关键问题" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h4 id="-如何改变-promise-的状态">Ⅰ-如何改变 promise 的状态?<a href="#-如何改变-promise-的状态" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) resolve(value): 如果当前是 pending 就会变为 resolved (fullfiled)</p>
<p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p>
<p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p>
</blockquote>
<h4 id="-一个-promise-指定多个成功失败回调函数-都会调用吗">Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?<a href="#-一个-promise-指定多个成功失败回调函数-都会调用吗" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">///指定回调1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//指定回调2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div></blockquote>
<h4 id="--改变-promise-状态和指定回调函数谁先谁后">Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?<a href="#--改变-promise-状态和指定回调函数谁先谁后" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p>
<p>​	①先指定回调再改变状态(<code>异步</code>):先指定回调&ndash;&gt; 再改变状态 &ndash;&gt;改变状态后才进入异步队列执行回调函数</p>
<p>​	② 先改状态再指定回调(<code>同步</code>):改变状态 &ndash;&gt;指定回调 ,<code>并马上执行</code>回调</p>
<p>(2) 如何先改状态再<code>指定</code>回调?   &ndash;&gt; 注意:指定并不是执行</p>
<p>​	① 在执行器中直接调用 resolve()/reject() &ndash;&gt;即,不使用定时器等方法,执行器内直接同步操作</p>
<p>​	② 延迟更长时间才调用 then() 	&ndash;&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p>
<p>(3) 什么时候才能得到数据?</p>
<p>​	① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p>
<p>​	② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//异步写法,这样写会先指定回调,再改变状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//这是同步写法,这样写会先改变状态,再指定回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>(4) 个人理解&ndash;结合源码</p>
<p>​          源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断,所以当<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后。这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功。所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的。具体代码实现看下方自定义promise。</p>
</blockquote>
<h4 id="-promisethen返回的新-promise-的结果状态由什么决定">Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?<a href="#-promisethen返回的新-promise-的结果状态由什么决定" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p>
<p>(2) 详细表达:</p>
<p>​	① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</p>
<p>​	② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p>
<p>​	③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//执行 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 抛出异常 ,变为 rejected
</span></span></span><span class="line"><span class="cl"><span class="c1">// throw &#39;出了问题&#39;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved
</span></span></span><span class="line"><span class="cl"><span class="c1">// return 521;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//return new Promise((resolve, reject) =&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  	<span class="c1">// resolve(&#39;success&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  	<span class="c1">// reject(&#39;error&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div></blockquote>
<h4 id="--promise-如何串连多个操作任务">Ⅴ- promise 如何串连多个操作任务?<a href="#--promise-如何串连多个操作任务" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 。</p>
<p>(2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;success&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//输出结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//success
</span></span></span><span class="line"><span class="cl"><span class="c1">//undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//分析：第二个then函数中应当返回一个promise对象，但是没有返回值，默认为undefined，
</span></span></span><span class="line"><span class="cl"><span class="c1">//因此第三个回调函数输出一个undefined.
</span></span></span></code></pre></div></blockquote>
<h4 id="-promise-异常传透">Ⅵ-promise 异常传透?<a href="#-promise-异常传透" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<ul>
<li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li>
<li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">),</span><span class="nx">e</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;被then的错误回调捕获&#39;</span><span class="p">,</span><span class="nx">e</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//执行结果: 被then的错误回调捕获 Error: 抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/******************** 利用异常穿透 ****************************************/</span>
</span></span><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//此处差异,不指定 reject 回调,利用异常穿透传到最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//执行结果:  错误捕获:  Error: 抛出异常
</span></span></span></code></pre></div><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../image/Promise_study/image-20210927105504988.png" alt="image-20210927105504988"></p>
</blockquote>
<h4 id="--中断-promise-链">Ⅶ- 中断 promise 链?<a href="#--中断-promise-链" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p>
<p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span><span class="c1">//有且只有这一个方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span></code></pre></div></blockquote>
<hr>
<h2 id="5-promise的实际应用">5、 Promise的实际应用<a href="#5-promise的实际应用" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="---加载图片">Ⅰ - 加载图片<a href="#---加载图片" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">preloadImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span>  <span class="o">=</span> <span class="nx">resolve</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></blockquote>
<h3 id="---generator-函数与-promise-的结合">Ⅱ - Generator 函数与 Promise 的结合<a href="#---generator-函数与-promise-的结合" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getFoo</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getFoo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">run</span> <span class="p">(</span><span class="nx">generator</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">go</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span>
</span></span></code></pre></div><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
</blockquote>
<hr>
<h1 id="二promise-api-用法详解">二、Promise API 用法详解<a href="#二promise-api-用法详解" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<blockquote>
<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p>
</blockquote>
<h2 id="----基本用法">Ⅰ -  基本用法<a href="#----基本用法" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h4 id="--举个创造-promise-实例的栗子">①  举个创造 Promise 实例的栗子<a href="#--举个创造-promise-实例的栗子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">)</span>  <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//将该 Promise 修改为成功且返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">else</span>  <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span> <span class="c1">//将该 Promise 修改为失败且返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
</blockquote>
<h4 id="-使用--then--方法分别指定-成功失败-的回调">② 使用 [ then ] 方法分别指定 成功/失败 的回调<a href="#-使用--then--方法分别指定-成功失败-的回调" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise</code>实例生成以后，可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当promise状态返回为resolve 时会执行的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当promise状态返回为rejected 时会执行的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的，不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
</blockquote>
<h4 id="-举个-promise-对象的简单栗子">③ 举个 Promise 对象的简单栗子<a href="#-举个-promise-对象的简单栗子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<blockquote>
<p>setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//声明一个方法, 传入的 参数ms 为延时器时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#39;努力学习的汪&#39;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">,</span> <span class="s1">&#39;努力学习的汪&#39;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">timeout</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//打印结果 : 努力学习的汪
</span></span></span></code></pre></div><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
</blockquote>
<h4 id="-promise-新建后就会立即执行">④ Promise 新建后就会立即执行<a href="#-promise-新建后就会立即执行" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;resolved.&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Promise
</span></span></span><span class="line"><span class="cl"><span class="c1">// Hi!
</span></span></span><span class="line"><span class="cl"><span class="c1">// resolved //可以发现,明明then是在 Hi 前面,却最后打印
</span></span></span></code></pre></div><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为:</p>
<ol>
<li>
<p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p>
</li>
<li>
<p>为何 resolve() 运行后没有立即打印?</p>
</li>
</ol>
<ul>
<li>
<p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p>
<blockquote>
<p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</p>
<p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</p>
</blockquote>
</li>
<li>
<p>JS执行时会区别这2个队列:</p>
<blockquote>
<p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p>
<p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="-举个异步加载图片的栗子">⑤ 举个异步加载图片的栗子<a href="#-举个异步加载图片的栗子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">loadImageAsync</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;图片加载成功&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="nx">resolve</span><span class="p">(</span><span class="nx">image</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`无法从 </span><span class="si">${</span><span class="nx">url</span><span class="si">}</span><span class="sb"> 中加载图片`</span> <span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">loadImageAsync</span><span class="p">(</span><span class="s1">&#39;正确的url&#39;</span><span class="p">)</span> <span class="c1">//打印图片加载成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">loadImageAsync</span><span class="p">(</span><span class="s1">&#39;错误的url&#39;</span><span class="p">)</span> <span class="c1">//抛出异常
</span></span></span></code></pre></div><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p><img src="../../image/Promise_study/image-20210926180306961.png" alt="image-20210926180306961"></p>
</blockquote>
<h4 id="-举个用promise对象实现的-ajax-操作的栗子">⑥ 举个用<code>Promise</code>对象实现的 Ajax 操作的栗子<a href="#-举个用promise对象实现的-ajax-操作的栗子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 &ndash;&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">!==</span> <span class="mi">4</span><span class="p">)</span>  <span class="k">return</span><span class="p">;</span> <span class="c1">//当readyState 为4 时直接返回,不修改 promise 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span> <span class="c1">//返回状态为 200 时将状态修改为成功,且将响应内容返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span>  <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statusText</span><span class="p">));</span> <span class="c1">//失败时抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span> <span class="c1">//实例化xml实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">client</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span> <span class="c1">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">client</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">client</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&#34;json&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">client</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">&#34;Accept&#34;</span><span class="p">,</span> <span class="s2">&#34;application/json&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Contents: &#39;</span> <span class="p">,</span> <span class="nx">json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p><img src="../../image/Promise_study/image-20210926182129672.png" alt="image-20210926182129672"></p>
<blockquote>
<p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p>
</blockquote>
<blockquote>
<p><img src="../../image/Promise_study/image-20210926182506259.png" alt="image-20210926182506259"></p>
</blockquote>
</blockquote>
<h4 id="--resolve--的参数可以是另一个-promise-实例">⑦  resolve()  的参数可以是另一个 Promise 实例<a href="#--resolve--的参数可以是另一个-promise-实例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="p">})</span>
</span></span></code></pre></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;p1的状态改为错误&#39;</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">),</span> <span class="mi">3000</span><span class="p">)</span> <span class="c1">//将p1 传给p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">),</span><span class="nx">result</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch异常捕获:&#39;</span><span class="o">+</span><span class="nx">error</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">//首先报错
</span></span></span><span class="line"><span class="cl"><span class="c1">//运行三秒后打印: 失败
</span></span></span></code></pre></div><h5 id="上面代码运行后执行效果">上面代码运行后执行效果:<a href="#上面代码运行后执行效果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<ul>
<li>首先马上会打印一个报错 : &ldquo;Uncaught (in promise) Error: p1的状态改为错误&rdquo; (红色报错)</li>
<li>然后等3秒后再打印:  &lsquo;失败&rsquo;</li>
<li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li>
</ul>
<h5 id="解释">解释:<a href="#解释" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<ul>
<li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li>
<li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态</li>
<li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li>
</ul>
</blockquote>
</blockquote>
<h4 id="-调用resolve或reject并不会终结-promise-的参数函数的执行">⑧ 调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行<a href="#-调用resolve或reject并不会终结-promise-的参数函数的执行" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1
</span></span></span></code></pre></div><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
</blockquote>
<h4 id="-建议在修改状态函数前加return">⑨ 建议在修改状态函数前加return<a href="#-建议在修改状态函数前加return" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 后面的语句不会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p>
</blockquote>
<h5 id="a-不加-return-导致的错误场景举">a) 不加 return 导致的错误场景举🌰<a href="#a-不加-return-导致的错误场景举" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch())</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功了&#39;</span><span class="p">);</span> <span class="c1">//如果你加了 return , 函数执行到此步就停止了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;错误错误!!!!!&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught Error: 错误错误!!!!
</span></span></span></code></pre></div><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
</blockquote>
<h2 id="----api-用法详解">Ⅱ -  API 用法详解<a href="#----api-用法详解" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>此处将对于所有API进行详细剖析,参照资料为 <a href="">阮一峰的ES6日志</a></p>
</blockquote>
<h4 id="-promiseprototypethen">① Promise.prototype.then()<a href="#-promiseprototypethen" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
</blockquote>
<h5 id="a-then方法返回的是一个新的promise实例">a) <code>then</code>方法返回的是一个新的<code>Promise</code>实例<a href="#a-then方法返回的是一个新的promise实例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`My name is </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
</blockquote>
<h5 id="b-采用链式的then-会等待前一个promise状态发生改变才会被调用">b) 采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用<a href="#b-采用链式的then-会等待前一个promise状态发生改变才会被调用" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;resolved: My name is &#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> 
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
</blockquote>
<h5 id="c-使用箭头函数简写">c) 使用箭头函数简写<a href="#c-使用箭头函数简写" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;./hong.json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span> <span class="p">=&gt;</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">json</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;resolved: My name is &#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl"><span class="nx">err</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h4 id="-promiseprototypecatch">② Promise.prototype.catch()<a href="#-promiseprototypecatch" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
</blockquote>
<h5 id="a-基本用法">a) 基本用法<a href="#a-基本用法" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;发生错误！&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象</p>
<blockquote>
<ul>
<li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；</li>
<li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误</li>
<li>另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</li>
<li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;指定成功回调:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;在catch中进行 rejected 的处理&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;指定成功回调:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;等同于另起一个then,只指定 rejected 的处理&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">));</span>
</span></span></code></pre></div></blockquote>
<h5 id="b--reject方法的作用等同于抛出错误">b)  <code>reject()</code>方法的作用，等同于抛出错误<a href="#b--reject方法的作用等同于抛出错误" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;直接抛出错误&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;异常捕获: &#39;</span><span class="p">,</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//异常捕获:  Error: 直接抛出错误
</span></span></span></code></pre></div><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="cm">/******************  写法一 ***************************************/</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;直接抛出错误&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;进入catch,然后再用 reject(e)抛出 &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//进入catch,然后再用 reject(e)抛出 
</span></span></span><span class="line"><span class="cl"><span class="c1">//Error: 直接抛出错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/******************  写法二 ***************************************/</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;使用 reject() 抛出错误&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise1</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Error: 使用 reject() 抛出错误
</span></span></span></code></pre></div><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p>
</blockquote>
<h5 id="c-如果-promise-状态已经被修改再抛出错误是无效的">c) 如果 Promise 状态已经被修改，再抛出错误是无效的<a href="#c-如果-promise-状态已经被修改再抛出错误是无效的" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功了&#39;</span><span class="p">);</span> <span class="c1">//换成 reject(&#39;成功了&#39;) 结果也是一样的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;成功后扔抛出异常&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 成功了
</span></span></span></code></pre></div><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过)</p>
</blockquote>
<h5 id="d-promise-对象的错误具有-冒泡-性质">d) Promise 对象的错误具有 “冒泡” 性质<a href="#d-promise-对象的错误具有-冒泡-性质" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span> <span class="c1">//第一个promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//第二个promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//第三个promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理前面三个Promise产生的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>也是因为这个特性,有了 <strong>异常穿透问题</strong></p>
</blockquote>
<h5 id="e-异常穿透问题">e) 异常穿透问题<a href="#e-异常穿透问题" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<ul>
<li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li>
<li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">),</span><span class="nx">e</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;被then的错误回调捕获&#39;</span><span class="p">,</span><span class="nx">e</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//执行结果: 被then的错误回调捕获 Error: 抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/******************** 利用异常穿透 ****************************************/</span>
</span></span><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抛出异常&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//此处差异,不指定 reject 回调,利用异常穿透传到最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//执行结果:  错误捕获:  Error: 抛出异常
</span></span></span></code></pre></div><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../image/Promise_study/image-20210927105504988.png" alt="image-20210927105504988"></p>
</blockquote>
<h5 id="f-建议使用-catch-进行异常处理">f) 建议使用 catch() 进行异常处理<a href="#f-建议使用-catch-进行异常处理" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">,</span><span class="nx">data</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/********* 好的写法 ********************/</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="nx">data</span><span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">,</span><span class="nx">data</span><span class="p">))</span> <span class="c1">//只指定成功回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="k">catch</span><span class="p">(</span> <span class="nx">err</span><span class="p">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">));</span>
</span></span></code></pre></div><p>上面代码中，第二种写法要好于第一种写法:</p>
<ul>
<li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li>
<li>也更接近同步的写法（<code>try/catch</code>）</li>
<li>因此, 建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</li>
</ul>
</blockquote>
<h5 id="g-与传统-trycatch-代码块的差异">g) 与传统 <code>try/catch</code> 代码块的差异<a href="#g-与传统-trycatch-代码块的差异" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面一行会报错，因为hong 没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Promise 的 then() 处理,但不处理异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;只指定成功回调,不处理异常错误&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught (in promise) ReferenceError: hong is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1">// 努力学习的汪
</span></span></span></code></pre></div><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。</p>
<blockquote>
<ul>
<li>浏览器运行到这一行，会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li>
<li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li>
<li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="h-catch方法后还能跟-then-方法">h) catch()方法后还能跟 then() 方法<a href="#h-catch方法后还能跟-then-方法" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面一行会报错，因为 hong 没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捉到错误咯:&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;错误捕获后我还要浪&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//捉到错误咯: ReferenceError: hong is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1">//错误捕获后我还要浪
</span></span></span></code></pre></div><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。</p>
<p>如果没有报错，则会跳过<code>catch()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;硬是成功了&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捉错误&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch后面的then: &#39;</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//catch后面的then:  硬是成功了
</span></span></span></code></pre></div><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
</blockquote>
<h5 id="i-catch方法之中还能再抛出错误">i) <code>catch()</code>方法之中，还能再抛出错误<a href="#i-catch方法之中还能再抛出错误" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面一行会报错，因为 hong 没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolve</span><span class="p">(</span> <span class="nx">hong</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span>  <span class="nx">someOtherAsyncThing</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ctach:&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面一行会报错，因为 sum 没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">sum</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕获后的then()&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ctach: [ReferenceError: hong is not defined]
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught (in promise) ReferenceError: sum is not defined
</span></span></span></code></pre></div><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">someOtherAsyncThing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下面一行会报错，因为 sum 没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sum</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;catch()后的catch: &#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//catch:  ReferenceError: hong is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1">//catch()后的catch:  ReferenceError: sum is not defined
</span></span></span></code></pre></div><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
</blockquote>
<h4 id="-promiseprototypefinally">③ Promise.prototype.finally()<a href="#-promiseprototypefinally" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="err">···</span><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<blockquote>
<ul>
<li><code>finally</code>方法的回调函数不接受任何参数，</li>
<li>这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li>
<li>这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="a-finally本质上是then方法的特例">a) <code>finally</code>本质上是<code>then</code>方法的特例<a href="#a-finally本质上是then方法的特例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">result</span> <span class="p">=&gt;</span>  <span class="nx">result</span> <span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">error</span> <span class="p">=&gt;</span>  <span class="k">throw</span> <span class="nx">error</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
</blockquote>
<h5 id="b-它的实现">b) 它的实现<a href="#b-它的实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>它的实现也很简单。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">P</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>  <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// resolve 的值是 undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// resolve 的值是 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// reject 的值是 undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// reject 的值是 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
</span></span></code></pre></div><p><img src="../image/Promise_study/image-20210927135255264.png" alt="image-20210927135255264"></p>
</blockquote>
<h4 id="-promiseall">④ Promise.all()<a href="#-promiseall" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span></code></pre></div><blockquote>
<ul>
<li><code>Promise.all()</code>方法接受一个数组作为参数，</li>
<li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</li>
<li>另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="a-返回的状态由什么决定">a) 返回的状态由什么决定?<a href="#a-返回的状态由什么决定" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<blockquote>
<ol>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li>
</ol>
</blockquote>
<h6 id="下面是一个具体的例子">下面是一个具体的例子。<a href="#下面是一个具体的例子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 生成一个Promise对象的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;hong&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span> <span class="nx">item</span><span class="o">+</span><span class="s1">&#39;.json&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>，或者<strong>其中有一个变为<code>rejected</code></strong>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<h6 id="下面是另一个例子">下面是另一个例子<a href="#下面是另一个例子" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">databasePromise</span> <span class="o">=</span> <span class="nx">connectDatabase</span><span class="p">();</span> <span class="c1">//假设定义了一个异步方法,此方法能拿到你需要的所有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">booksPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>     <span class="c1">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">findAllBooks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">userPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>    <span class="c1">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">getCurrentUser</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="nx">booksPromise</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">userPromise</span>
</span></span><span class="line"><span class="cl"><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">pickTopRecommendations</span><span class="p">(</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">));</span>
</span></span></code></pre></div><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
</blockquote>
<h5 id="b-如果参数中的promise实例定义了自己的catch方法-">b) 如果参数中的Promise实例定义了自己的catch方法 ?<a href="#b-如果参数中的promise实例定义了自己的catch方法-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">//定义一个状态将为成功的的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//定义一个将抛出错误的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2自己的catch捕获: &#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">e</span><span class="p">;</span> <span class="c1">//异常获取后原样返回,不做修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用 Promise.all 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39; Promise.all 方法中的成功回调: &#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34; Promise.all 方法中的catch&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//p2自己的catch捕获:  Error: 报错了
</span></span></span><span class="line"><span class="cl"><span class="c1">// Promise.all 方法中的成功回调:  (2) [&#39;hello&#39;, Error: 报错了]
</span></span></span></code></pre></div><p>上面代码中，</p>
<blockquote>
<ul>
<li><code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code></li>
<li>但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。</li>
<li>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li>
<li>因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数</li>
</ul>
</blockquote>
</blockquote>
<h5 id="c--如果参数中的promise实例-没有-定义自己的catch方法-">c)  如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?<a href="#c--如果参数中的promise实例-没有-定义自己的catch方法-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">//定义一个状态将为成功的的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//定义一个将抛出错误的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用 Promise.all 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39; Promise.all 方法中的成功回调: &#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34; Promise.all 方法中的catch&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.all 方法中的catch Error: 报错了
</span></span></span></code></pre></div></blockquote>
<h4 id="-promiserace">⑤ Promise.race()<a href="#-promiserace" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span></code></pre></div><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
</blockquote>
<h5 id="a-举个简单的">a) 举个简单的🌰<a href="#a-举个简单的" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h5 id="b-举个应用实">b) 举个应用实🌰<a href="#b-举个应用实" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;请求超时!!!!&#39;</span><span class="p">)),</span> <span class="mi">5000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span>
</span></span></code></pre></div><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<p>是不是很好用又简单</p>
</blockquote>
<h4 id="-promiseallsettled">⑥ Promise.allSettled()<a href="#-promiseallsettled" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p>
<p><strong>只有等到所有这些参数实例都返回结果</strong>，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p>
<p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p>
</blockquote>
<h5 id="a-举个简单的-1">a) 举个简单的🌰<a href="#a-举个简单的-1" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">loading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">loading</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span></code></pre></div><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
</blockquote>
<h5 id="b--该方法返回的新的-promise-实例一旦结束状态总是fulfilled不会变成rejected">b)  该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code><a href="#b--该方法返回的新的-promise-实例一旦结束状态总是fulfilled不会变成rejected" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;返回成功状态的promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;返回失败状态的promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">allSettledPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">allSettledPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">[
</span></span></span><span class="line"><span class="cl"><span class="cm">  { &#34;status&#34;: &#34;fulfilled&#34;, &#34;value&#34;: &#34;返回成功状态的promise&#34; },
</span></span></span><span class="line"><span class="cl"><span class="cm">  { &#34;status&#34;: &#34;rejected&#34;, &#34;reason&#34;: &#34;返回失败状态的promise&#34; }
</span></span></span><span class="line"><span class="cl"><span class="cm">]
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></div><blockquote>
<ul>
<li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li>
<li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li>
<li>每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li>
<li><code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="c-举个返回值用法的">c) 举个返回值用法的🌰<a href="#c-举个返回值用法的" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">),</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">)</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 过滤出成功的请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">successfulPromises</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 过滤出失败的请求，并取得它们的失败原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">errors</span> <span class="o">=</span> <span class="nx">results</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span></code></pre></div><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">urls</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;https://gitee.com/hongjilin&#39;</span> <span class="p">,</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">requests</span> <span class="o">=</span> <span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//举例用 Promise.all 尝试实现,很明显,难以实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">requests</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;所有请求都成功。&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;至少一个请求失败，其他请求可能还没结束。&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了</p>
</blockquote>
<h4 id="-promiseany">⑦ Promise.any()<a href="#-promiseany" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
</blockquote>
<h5 id="a-与-promiserace-方法的区别">a) 与 <code>Promise.race()</code> 方法的区别<a href="#a-与-promiserace-方法的区别" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://github.com/Hongjilin&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./hong.json&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
</blockquote>
<h5 id="b-promiseany-抛出的错误">b) Promise.any() 抛出的错误<a href="#b-promiseany-抛出的错误" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">AggregateError</span><span class="p">()</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="o">-&gt;</span> <span class="nx">AggregateError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AggregateError</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">err</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;first error&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">err</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;second error&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span></code></pre></div><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Any of the promises was fulfilled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},(</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// All of the promises were rejected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h5 id="c-再举个">c) 再举个🌰<a href="#c-再举个" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;失败了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">alsoRejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;太失败了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">([</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">,</span> <span class="nx">alsoRejected</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// 成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">([</span><span class="nx">rejected</span><span class="p">,</span> <span class="nx">alsoRejected</span><span class="p">]).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>  <span class="c1">//AggregateError: All promises were rejected
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p>
</blockquote>
<h4 id="-promiseresolve">⑧ Promise.resolve()<a href="#-promiseresolve" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">jsPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;https://gitee.com/hongjilin&#39;</span><span class="p">));</span>
</span></span></code></pre></div><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">))</span>
</span></span></code></pre></div><p><code>Promise.resolve()</code>方法的参数分成四种情况</p>
</blockquote>
<h5 id="a-参数是一个-promise-实例">a) 参数是一个 Promise 实例<a href="#a-参数是一个-promise-实例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
</blockquote>
<h5 id="b-参数是一个thenable对象"><strong>b) 参数是一个<code>thenable</code>对象</strong><a href="#b-参数是一个thenable对象" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	<span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;成功&#39;</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>  <span class="c1">// &#39;成功&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></div><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出 <strong>&lsquo;成功&rsquo;</strong>。</p>
</blockquote>
<h5 id="c-参数不是具有then方法的对象或根本就不是对象">c) 参数不是具有<code>then()</code>方法的对象，或根本就不是对象<a href="#c-参数不是具有then方法的对象或根本就不是对象" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;努力学习的汪&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 努力学习的汪
</span></span></span></code></pre></div><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p>
<blockquote>
<ul>
<li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li>
<li>返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行</li>
<li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li>
</ul>
</blockquote>
</blockquote>
<h5 id="d-不带有任何参数">d) 不带有任何参数<a href="#d-不带有任何参数" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{});</span>
</span></span></code></pre></div><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 &ndash;&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8Bevent-loop%E6%9C%BA%E5%88%B6">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">);</span> <span class="c1">//这里是新的一轮事件循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">);</span> <span class="c1">//本轮同步代码结束后,新一轮事件循环前,就执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// one
</span></span></span><span class="line"><span class="cl"><span class="c1">// two
</span></span></span><span class="line"><span class="cl"><span class="c1">// three
</span></span></span></code></pre></div><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log('one')</code>则是立即执行，因此最先输出。</p>
</blockquote>
<h4 id="-promisereject">⑨ Promise.reject()<a href="#-promisereject" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出错了
</span></span></span></code></pre></div><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span> <span class="o">===</span> <span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
</blockquote>
<h4 id="-promisetry">⑩ Promise.try()<a href="#-promisetry" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span></code></pre></div><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// next
</span></span></span><span class="line"><span class="cl"><span class="c1">// now
</span></span></span></code></pre></div><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<h6 id="那么有没有一种方法让同步函数同步执行异步函数异步执行并且让它们具有统一的-api-呢">那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？<a href="#那么有没有一种方法让同步函数同步执行异步函数异步执行并且让它们具有统一的-api-呢" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
</blockquote>
<h5 id="a-写法一--用async函数来写">a) 写法一 : 用<code>async</code>函数来写<a href="#a-写法一--用async函数来写" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now
</span></span></span><span class="line"><span class="cl"><span class="c1">// next
</span></span></span></code></pre></div><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span></code></pre></div><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</span></span></code></pre></div></blockquote>
<h5 id="b--写法二--使用new-promise">b)  写法二 : 使用<code>new Promise()</code><a href="#b--写法二--使用new-promise" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now
</span></span></span><span class="line"><span class="cl"><span class="c1">// next
</span></span></span></code></pre></div><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
</blockquote>
<h5 id="c-promisetry的引出">c) Promise.try的引出<a href="#c-promisetry的引出" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<blockquote>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now
</span></span></span><span class="line"><span class="cl"><span class="c1">// next
</span></span></span></code></pre></div><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getUsername</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</span></span></code></pre></div><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</span></span></code></pre></div><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
</blockquote>
<hr>
<h1 id="三自定义promise手写">三、自定义Promise手写<a href="#三自定义promise手写" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<blockquote>
<ol>
<li>下方的<code>Promise.prototype.then</code>与<code>Promise.resolve</code>为什么一个挂载在<code>prototype</code>而另一个挂载在实例对象上?</li>
</ol>
<p>解:原因是分别为静态方法与实例方法</p>
<p>&ndash;&gt;上面的需要new实例化的时候自动继承实例<code>prototype</code>上的方法和属性,所以用<code>实例对象.then()</code>来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用</p>
<h2 id="此部分可以跳过不看类似手撕源码"><strong>此部分可以跳过不看,类似手撕源码</strong><a href="#此部分可以跳过不看类似手撕源码" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
</blockquote>
<h2 id="-promise的实例方法实现">Ⅰ-Promise的实例方法实现<a href="#-promise的实例方法实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="1---初始结构搭建">1 - 初始结构搭建<a href="#1---初始结构搭建" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>html引入,该章节后续html大部分重复 除非必要,否则不再放上来</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Promise-封装 | 1 - 初始结构搭建<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./promise.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span> <span class="nx">reason</span><span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></div><blockquote>
<p>promise.js  &ndash;&gt;使用原生写法,最后会改为class写法</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){}</span>
</span></span></code></pre></div><h3 id="2---resolve-与-reject构建与基础实现">2 - resolve 与 reject构建与基础实现<a href="#2---resolve-与-reject构建与基础实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>使用<code>const self = this;</code>保存this执行,使function中可以取得当前实例</li>
</ol>
<p>ps:可以不使用该方法保存,但是下方function需要<code>改为箭头函数</code>,否则<code>function默认指向是window</code></p>
<p>之后代码默认使用<code>self</code>保存this,箭头函数方式将在最后改为class写法时使用</p>
<ol start="2">
<li>默认设置 <code>PromiseState = 'pending'以及 PromiseResult = null</code>,这就是promise状态基础</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//声明构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//添加属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//保存实例对象的 this 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*  此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">//resolve 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span><span class="o">--------------------------------------------</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="c1">// resolved
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span><span class="o">----------------------------------------------</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//同步调用『执行器函数』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></div><h3 id="3---throw-抛出异常改变状态">3 - throw 抛出异常改变状态<a href="#3---throw-抛出异常改变状态" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>在2的基础上进行修改:将执行器放入<code>try-catch()</code>中</li>
<li>在catch中使用<code>reject()</code>修改 promise 对象状态为『<code>失败</code>』</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"> <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//同步调用『执行器函数』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//修改 promise 对象状态为『失败』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h3 id="4---状态只能修改一次">4 - 状态只能修改一次<a href="#4---状态只能修改一次" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>基于2 3代码中resolve和reject方法进修改</p>
</li>
<li>
<p>在成功与失败函数中添加判断<code> if(self.PromiseState !== 'pending') return;</code>,如果进入函数时状态不为<code>pending</code>直接退出,这样就能做到状态只能从<code>pending</code>改至其他状态且做到只能改一次</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">--------------------------------------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// throw &#34;error&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改</span><span class="o">--------------------------------------------------------</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//resolve 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span><span class="c1">// resolved
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h3 id="5---then-方法执行回调基础实现">5 - then 方法执行回调基础实现<a href="#5---then-方法执行回调基础实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>修改<code>Promise.prototype.then</code>方法</li>
<li>传入<code>then(成功回调,失败回调)</code>,当调用then后,会判断当前<code>this.PromiseState</code>的状态,当其为成功时调用<code>成功回调</code>,失败时调用<code>失败回调</code></li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// resolve(&#39;OK&#39;);// reject(&#34;Error&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">throw</span> <span class="s2">&#34;ERROR&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">},</span> 
</span></span><span class="line"><span class="cl">        <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="6---异步任务-then-方法实现">6 - 异步任务 then 方法实现<a href="#6---异步任务-then-方法实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>此处对于5有四处修改,下面上<code>js代码</code></p>
</li>
<li>
<p>当我运行<code>异步代码</code>后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的<code>p</code>为<code>pending</code>状态,所以根本不会执行resolve与reject方法</p>
</li>
</ol>
<p>解:添加判断<code>pending</code>状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到</p>
<ol start="3">
<li>为什么要将回调保存到实例上而不是直接调用?</li>
</ol>
<p><code>理由</code>:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数
所以当你调用<code>then()</code>时却检测到状态为<code>pending</code>,说明这时候的promise在异步队列 不能直接运行成功或者失败函数</p>
<p><code>解决</code>:因为<code>resolve与reject</code>方法与<code>then()</code>不在同一个作用域中,并不能共享<code>then(成功回调,失败回调)</code>的参数,所以在判断状态为<code>pending</code>时将回调保存到实例对象上.然后将回调函数的调用放在<code>resolve()与reject()</code>中</p>
<p>这样当我代码运行到异步队列的<code>resolve()或reject()</code>时,就可以在这个函数中运行回调函数,实现异步then</p>
<ol start="4">
<li>此处的then<code>仍有瑕疵</code>,需要继续完善</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//实例化对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span> <span class="cm">/* resolve(&#39;OK&#39;);*/</span><span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//声明构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 声明属性     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="p">{};</span>			<span class="o">-----------</span><span class="nx">新添加1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="c1">//resolve 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用成功的回调函数  加判断的原因是防止无回调报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">}</span>  <span class="o">------------</span><span class="nx">新添加2</span> <span class="nx">最重要</span> 
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行回调						
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);}</span>  <span class="o">------------</span><span class="nx">新添加3</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span><span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>  <span class="o">------------</span><span class="nx">新添加4</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//保存回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="7---指定多个回调">7 - 指定多个回调<a href="#7---指定多个回调" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>基于6代码进行修改 只展示修改部分代码</p>
</li>
<li>
<p><code>6</code>中保存回调函数的方式有BUG,如果我有多个<code>.then()</code>,后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数<code>有且只有</code>最后一个</p>
</li>
</ol>
<p>解:使用<code>数组</code>的方式进行存储回调函数,调用时也是用数组循环取出</p>
<ol start="3">
<li>此处的then<code>仍有瑕疵</code>,需要继续完善</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//实例化对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;No&#39;</span><span class="p">);},</span> <span class="mi">1000</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">   <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span> <span class="nx">reason</span><span class="p">=&gt;{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">   <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);},</span> <span class="nx">reason</span><span class="p">=&gt;{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//resolve 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  		<span class="p">.....</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//调用成功的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// if (self.callback.onResolved) { self.callback.onResolved(data); } 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>   <span class="o">--------</span><span class="nx">修改1</span>
</span></span><span class="line"><span class="cl">            <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">     	 <span class="p">......</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//执行失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// if (self.callback.onResolved) { self.callback.onResolved(data);}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>		<span class="o">------</span><span class="nx">修改2</span>
</span></span><span class="line"><span class="cl">            <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="p">........</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//保存回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  this.callback = { onResolved: onResolved, onRejected: onRejected }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>					<span class="o">--------</span><span class="nx">修改3</span>
</span></span><span class="line"><span class="cl">            <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="8---同步任务-then-返回结果">8 - 同步任务 then 返回结果<a href="#8---同步任务-then-返回结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>在之前的then运行结果中得知,我们使用  [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象</li>
</ol>
<p>解:所以我们在then中<code>return new Promise()</code>,使其得到的是一个新的promise对象</p>
<ol start="2">
<li>在为<code>解决问题1</code>后产生一个新问题:新的promise对象因为没有用<code>rejerect与resolve</code>方法,导致返回的状态一直是<code>pending</code></li>
</ol>
<p>解:在新的promise中判断<code>运行回调函数</code>后的返回值是什么,然后根据其不同类型给其赋予不同状态</p>
<p>​	Ⅰ-<code>if(result instanceof Promise)</code>:返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称<code>②promise对象</code>),在返回值(因为是promise对象)的<code>.then()</code>回调函数中使用rejerect与resolve方法,将其<code>自身的状态</code>赋予外层的promise,</p>
<p>​	即 回调函数中的promise 赋值 给then返回值 ,  所以 <code>最终返回状态==回调函数中的新promise状态</code></p>
<p>​	Ⅱ-如果返回值是一个<code>非promise</code>对象,返回状态设置为成功</p>
<p>​	Ⅲ-如果返回值是一个异常,返回状态设置为失败</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//实例化对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="s2">&#34;FAIL&#34;</span><span class="p">;},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//  if(this.PromiseState === &#39;fulfilled&#39;){ onResolved(this.PromiseResult);} 未修改时代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">){</span>    <span class="o">-------</span><span class="nx">修改1</span> 
</span></span><span class="line"><span class="cl">            <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//获取回调函数的执行结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onResolved</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">){</span><span class="c1">//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>  <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="p">},</span><span class="nx">r</span><span class="p">=&gt;{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);})</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>  <span class="c1">//如果返回的不是promise对象,都将其赋予成功状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nx">rejerect</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>	<span class="c1">//如果出错了,则返回失败状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">){</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);}</span><span class="o">------</span><span class="nx">此部分修改与修改1一样</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="9---异步任务-then-返回结果">9 - 异步任务 then 返回结果<a href="#9---异步任务-then-返回结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>异步任务是修改<code>if(this.PromiseState === 'pending')</code>后面的值,原因参考<code>6</code>,下面代码只举例这部分修改</p>
</li>
<li>
<p>因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行<code>加工</code>,<code>添加判断其回调函数的返回值</code>的代码块再存入实例的回调函数中</p>
</li>
</ol>
<p>Ⅰ-声明一个新的函数:其内部功能-&gt;先运行<code>onResolved回调函数</code>,再将其返回值取出,进行判断其返回值(这个过程同<code>8</code>)</p>
<p>Ⅱ-加工后存入实例回调函数数组,之后在<code>resolve与reject</code>方法中调用即可(同<code>6</code>)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//实例化对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;Error&#34;</span><span class="p">);},</span> <span class="mi">1000</span><span class="p">)});</span> <span class="c1">// resolve(&#39;OK&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//执行 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// return &#39;oh Yeah&#39;;  //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">throw</span> <span class="s1">&#39;error&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="s2">&#34;xx&#34;</span><span class="p">);</span> <span class="c1">//如果只是打印没返回,则实际上时返回一个undefined,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="s2">&#34;sss&#34;</span>   <span class="c1">// throw &#39;error&#39;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//保存回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//执行成功回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onResolved</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//判断 其结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);},</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">                 <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//执行成功回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">                 <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h3 id="10--then方法代码优化">10- then方法代码优化<a href="#10--then方法代码优化" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">封装函数</span><span class="o">----------------------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//获取回调函数的执行结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">type</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//如果是 Promise 类型的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//结果的对象状态为『成功』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">-----------------------------------------------------------------------------------</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//保存回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="11---catch-方法与异常穿透与值传递">11 - catch 方法与异常穿透与值传递<a href="#11---catch-方法与异常穿透与值传递" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>异常穿透:添加<code>catch 方法 </code>,并且需要进行回调函数为<code>undefined的</code>处理</p>
</li>
<li>
<p>当我<code>then()</code>中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是<code>undefined</code></p>
</li>
</ol>
<p>解:进行回调函数判断,当其为空时,基于默认回调函数内容:<code>直接往外抛出</code>这样下方的<code>then() or catch()</code>就可以承接到异常或者值</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
</span></span><span class="line"><span class="cl"><span class="c1">//实例化对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//值传递
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);})</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);})</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>				<span class="o">-----------</span><span class="nx">修改1</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onRejected</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span><span class="nx">onRejected</span> <span class="o">=</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span><span class="p">;}}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onResolved</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="nx">onResolved</span> <span class="o">=</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">	 <span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 catch 方法  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">catch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">){</span>  <span class="o">---------------</span><span class="nx">异常穿透</span> <span class="nx">修改2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="-promise的静态方法实现">Ⅱ-Promise的静态方法实现<a href="#-promise的静态方法实现" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="1---promiseresolve-封装">1 - Promise.resolve 封装<a href="#1---promiseresolve-封装" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>
<p>判断传入的参数是否为<code>promise对象</code>:</p>
<p>Ⅰ-如果为<code>promise</code>:将其状态与结果赋值给外层promise对象</p>
<p>Ⅱ-如果为<code>非promise</code>:状态设置为成功</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">      <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;error&#34;</span><span class="p">);</span><span class="c1">// resolve(&#39;Success&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}));</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 resolve 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//返回promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="nx">v</span><span class="p">=&gt;{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);},</span>
</span></span><span class="line"><span class="cl">                <span class="nx">r</span><span class="p">=&gt;{</span><span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">            <span class="p">)}</span><span class="k">else</span><span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">}</span><span class="c1">//状态设置为成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2---promiseresolve-封装">2 - Promise.resolve 封装<a href="#2---promiseresolve-封装" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为<code>失败</code>即可</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
</span></span><span class="line"><span class="cl">   <span class="c1">//Promise.reject
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}));</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 reject 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="3---promiseall-封装">3 - Promise.all 封装<a href="#3---promiseall-封装" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回<code>成功</code>状态</li>
<li>如果当数组中任意一个promise的执行结果是<code>reject</code>,直接中断,返回状态为<code>失败</code></li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用 all 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 all 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//返回结果为promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//声明变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//得知对象的状态是成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//每个promise对象 都成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//将当前promise对象成功的结果 存入到数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);}</span><span class="c1">//修改状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="4---promiserace-封装">4 - Promise.race 封装<a href="#4---promiserace-封装" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>直接谁先执行就返回谁的运行结果即可</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">html调用</span><span class="o">------------------------------------------------------------</span>  
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Success&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Oh Yeah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用 race 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">js修改与实现</span><span class="o">-----------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加 race 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//修改返回对象的状态为 『成功』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//修改返回对象的状态为 『失败』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="-其他优化">Ⅲ-其他优化<a href="#-其他优化" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="1---回调函数异步执行">1 - 回调函数『异步执行』<a href="#1---回调函数异步执行" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>如果我们运行下面代码,正确顺序是: 111 &ndash;&gt; 333 &ndash;&gt;444</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">111</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">222</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">444</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">333</span><span class="p">);</span>
</span></span></code></pre></div><ol start="2">
<li>但当我们运行之前封装的 <strong>Promise</strong> 代码时,结果却是:111 &ndash;&gt; 444 &ndash;&gt; 333</li>
</ol>
<p>我们需要将我们的then方法变成<code>异步方法</code></p>
<ol start="3">
<li>我们只要在以下四处地方的<code>回调函数调用</code>外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">});</span> <span class="p">});</span><span class="o">--</span><span class="nx">修改1</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">});</span> <span class="p">});</span><span class="o">---</span><span class="nx">修改2</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 then 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="cm">/*  修改前代码
</span></span></span><span class="line"><span class="cl"><span class="cm">     if (this.PromiseState === &#39;fulfilled&#39;) { callback(onResolved); }
</span></span></span><span class="line"><span class="cl"><span class="cm"> 		if (this.PromiseState === &#39;rejected&#39;) { callback(onRejected);
</span></span></span><span class="line"><span class="cl"><span class="cm"> 		 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">){</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);});}</span>  <span class="o">-----</span><span class="nx">修改3</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">){</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);});</span>   <span class="o">---</span><span class="nx">修改4</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li><code>相关原理参照js事件循环机制、宏任务与微任务</code></li>
</ol>
</blockquote>
<h3 id="2--class改写promise">2- class改写promise<a href="#2--class改写promise" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<ol>
<li>其中将<code>self=this</code>保存this指向方式改为箭头函数表示(在上面示例中也有效果)</li>
<li>将其改为class写法</li>
<li>下面为promisedemo.js代码</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nb">Promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">constructor</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//添加属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//声明属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//保存实例对象的 this 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//resolve 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span> <span class="c1">// resolved
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用成功的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">item</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//reject 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">reject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">!==</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 修改对象的状态 (promiseState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span> <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//2. 设置对象结果值 (promiseResult)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">item</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//同步调用『执行器函数』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//修改 promise 对象状态为『失败』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//then 方法封装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">then</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//判断回调函数参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onRejected</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">onRejected</span> <span class="o">=</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="nx">reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">onResolved</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">onResolved</span> <span class="o">=</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//value =&gt; { return value};
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//封装函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">callback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//获取回调函数的执行结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">type</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//如果是 Promise 类型的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">result</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//结果的对象状态为『成功』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用回调函数  PromiseState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断 pending 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">PromiseState</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//保存回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onResolved</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">callback</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onRejected</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">callback</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//catch 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">catch</span> <span class="p">(</span><span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 resolve 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">static</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//返回promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//状态设置为成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 reject 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">static</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 all 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">static</span> <span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//返回结果为promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//声明变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//得知对象的状态是成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//每个promise对象 都成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//将当前promise对象成功的结果 存入到数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//修改状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//添加 race 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">static</span> <span class="nx">race</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//修改返回对象的状态为 『成功』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span> <span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//修改返回对象的状态为 『失败』
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>html文件调用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>class版本封装<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./promisedemo.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// resolve(&#34;OK&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">reject</span><span class="p">(</span><span class="s2">&#34;Erosssr&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></div></blockquote>
<h1 id="三promise-async--await">三、Promise+ async + await<a href="#三promise-async--await" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<blockquote>
<h5 id="1promise异步">1)Promise==&gt;异步<a href="#1promise异步" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<h5 id="2await异步转同步">2)await==&gt;异步转同步<a href="#2await异步转同步" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<ol>
<li>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</li>
<li>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行</li>
</ol>
<h5 id="3async同步转异步">3)async==&gt;同步转异步<a href="#3async同步转异步" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h5>
<ol>
<li>方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</li>
</ol>
<h6 id="4mdn文档">4)mdn文档<a href="#4mdn文档" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h6>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li>
</ol>
</blockquote>
<h2 id="-async函数">Ⅰ-async函数<a href="#-async函数" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<ol>
<li>
<p>函数的返回值为 promise 对象</p>
</li>
<li>
<p>promise 对象的结果由 async 函数执行的返回值决定</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 如果返回值是一个非Promise类型的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// return 521;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2. 如果返回的是一个Promise对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// return new Promise((resolve, reject) =&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     // resolve(&#39;OK&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     reject(&#39;Error&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// });
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3. 抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// throw &#34;Oh NO&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">main</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h2 id="-await表达式">Ⅱ-await表达式<a href="#-await表达式" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<ol>
<li>
<p>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</p>
</li>
<li>
<p>如果表达式是 promise 对象, await 返回的是 promise 成功的值</p>
</li>
<li>
<p>如果表达式是其它值, 直接将此值作为 await 的返回值</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// resolve(&#39;OK&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1. 右侧为promise的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// let res = await p;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2. 右侧为其他类型的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// let res2 = await 20;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3. 如果promise是失败的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">res3</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">main</span><span class="p">();</span>
</span></span></code></pre></div></blockquote>
<h2 id="-注意">Ⅲ-注意<a href="#-注意" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<ol>
<li>await 必须写在 async 函数中, 但 async 函数中可以没有 await</li>
<li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try&hellip;catch 捕获处理</li>
</ol>
</blockquote>
<h2 id="-自己对某些问题理解解答">Ⅳ-自己对某些问题理解解答<a href="#-自己对某些问题理解解答" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="1如何在promise外部使用promise的结果">1、如何在Promise外部使用Promise的结果<a href="#1如何在promise外部使用promise的结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<blockquote>
<p>用到的本章节知识:</p>
<p>1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将<code>new Promise(resolve =&gt; {setTimeout(function() { resolve(&quot;promise普通结果&quot;); }, 1000); })</code>等价于<code>axios({})</code></p>
<p>2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次</p>
<p>3、 上一步抛出后可以在下面 的.then()中获取到</p>
<p>Ⅰ-如果没有用.then(),则值会抛往Promise外部</p>
<p>Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出&ndash;<code>某些业务场景需要</code> ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) &mdash;前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//讲解时写的简单demo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">resolveCommon</span> <span class="o">=</span> <span class="p">()=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result</span><span class="o">=</span><span class="s2">&#34;普通promise初始值&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="o">=</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;promise普通结果&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">1000</span><span class="p">);})</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//打印结果: Promise { &lt;pending&gt; } 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">resolveAsync</span><span class="o">=</span><span class="kr">async</span> <span class="p">()=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result</span><span class="o">=</span><span class="s2">&#34;await+async的promise初始值&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="o">=</span><span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;这是async+await结果&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//打印结果: 这是async+await结果  这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中
</span></span></span><span class="line"><span class="cl"><span class="c1">//------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1">//在第二个promise中调用使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result2</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">result2</span><span class="o">=</span> <span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="o">+</span><span class="s2">&#34;+经过第二个promise加工&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span><span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;第二个promise的then()中打印并返回:&#34;</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">v</span><span class="o">+</span><span class="s2">&#34;,经过then()加工返回&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;最终结果:第二个promise外部结果打印,&#34;</span><span class="p">,</span><span class="nx">result2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolveCommon</span><span class="p">()</span>  <span class="c1">//调用普通promise函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">resolveAsync</span><span class="p">()</span>    <span class="c1">//调用await+async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">运行结果
</span></span></span><span class="line"><span class="cl"><span class="cm">1.resolveCommon() 运行结果:    Promise { &lt;pending&gt; }
</span></span></span><span class="line"><span class="cl"><span class="cm">2.resolveAsync() 运行结果:     
</span></span></span><span class="line"><span class="cl"><span class="cm">这是async+await结果
</span></span></span><span class="line"><span class="cl"><span class="cm">第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工
</span></span></span><span class="line"><span class="cl"><span class="cm">最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></div><p>原因解析:</p>
<ol>
<li>new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列</li>
</ol>
<p>所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { <!-- raw HTML omitted --> } 对象</p>
<ol start="2">
<li>而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值</li>
</ol>
<p>所以下面的任务就可以使用到这个值</p>
<ol start="3">
<li>为什么这些操作要放在同一个async fn()=&gt;{} 中?</li>
</ol>
<p>1)Promise==&gt;异步</p>
<p>2)await==&gt;异步转同步</p>
<ol>
<li>
<p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</p>
</li>
<li>
<p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行</p>
</li>
</ol>
<p>3)async==&gt;同步转异步</p>
<p>方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</p>
</blockquote>
<h1 id="四宏任务与微任务">四、宏任务与微任务<a href="#四宏任务与微任务" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<h2 id="-说明">Ⅰ-说明<a href="#-说明" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>原理图:</p>
<p><img src="../../image/Promise_study/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Promise系统学习_宏任务微任务原理图"></p>
<p>说明:</p>
<ol>
<li>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</li>
</ol>
<ul>
<li><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</li>
<li><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</li>
</ul>
<ol start="2">
<li>JS执行时会区别这2个队列:</li>
</ol>
<ul>
<li>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</li>
<li>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</li>
<li><strong>同步任务</strong> &ndash;&gt; <strong>微任务</strong> &ndash;&gt; <strong>宏任务</strong></li>
</ul>
</blockquote>
<h2 id="-代码与示例">Ⅱ-代码与示例<a href="#-代码与示例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序</p>
</blockquote>
<h3 id="1代码示例">1、代码示例:<a href="#1代码示例" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<h4 id="a-首先给出注释的栗子举一个">a) 首先给出注释的栗子举一个<a href="#a-首先给出注释的栗子举一个" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>此处会给出每个打印放入什么队列,加深你的印象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback1（）&#39;</span><span class="p">)</span><span class="c1">//立即放入宏队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved3()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback2（）&#39;</span><span class="p">)</span> <span class="c1">//立即放入宏队列,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved1()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//立即放入微队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout callback3（）&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="c1">//立即放入宏任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise onResolved2()&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span><span class="c1">//立即放入微队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;同步代码&#39;</span><span class="p">)</span> <span class="c1">//同步代码立即执行
</span></span></span></code></pre></div><p>结果放在下方,就怕你不小心瞄到</p>
</blockquote>
<h4 id="b-尝试自己思考下">b) 尝试自己思考下<a href="#b-尝试自己思考下" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p>尝试自己脑海中用自己理解 &lsquo;运行&rsquo; 一下, 然后把结果写下来,再去下面结果做对比</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;代码开始执行&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;开始for循环&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span> <span class="o">==</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="nx">resolve</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行then函数&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;代码执行结束&#39;</span><span class="p">);</span>
</span></span></code></pre></div></blockquote>
<h3 id="2示例结果">2、示例结果:<a href="#2示例结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<h4 id="a-第一个栗子的结果">a) 第一个栗子的结果<a href="#a-第一个栗子的结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;同步代码&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Promise onResolved1()&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Promise onResolved2()&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;timeout callback1（）&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Promise onResolved3()&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;timeout callback2（）&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;timeout callback3（）&#39;</span>
</span></span></code></pre></div></blockquote>
<h4 id="b-第二个栗子的结果">b) 第二个栗子的结果<a href="#b-第二个栗子的结果" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h4>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827094130354.png" alt="image-20210827094130354"></p>
<p>PS: 可以忽略<code>undefined</code>这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担.</p>
<p>当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释</p>
</blockquote>
<h1 id="五对浏览器console控制台输出undefined的分析">五、对浏览器console控制台输出undefined的分析<a href="#五对浏览器console控制台输出undefined的分析" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<h2 id="--出现场景">Ⅰ- 出现场景<a href="#--出现场景" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827095144833.png" alt="image-20210827095144833"></p>
</blockquote>
<h2 id="---尝试输入其他内容进行分析">Ⅱ - 尝试输入其他内容进行分析<a href="#---尝试输入其他内容进行分析" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827095702736.png" alt="image-20210827095702736"></p>
<p>那么做个合理推测: 应该是在控制台输入的内容,它的 <code>返回值</code> 会显示出来,这让我们不禁想到JS的 [ <strong>eval()</strong> ]</p>
</blockquote>
<h2 id="---evalstring">Ⅲ - eval（string）<a href="#---evalstring" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值；</p>
<p>如果是没有返回值的表达式或语句，则会返回 undefined ；</p>
<p>如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。</p>
<p>于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数</p>
</blockquote>
<h2 id="---验证一下">Ⅳ - 验证一下<a href="#---验证一下" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p><img src="../../image/Promise_study/image-20210827100156570.png" alt="image-20210827100156570"></p>
<p>大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧</p>
</blockquote>
<h2 id="----分析其在宏任务与微任务的打印顺序">Ⅴ -  分析其在宏任务与微任务的打印顺序<a href="#----分析其在宏任务与微任务的打印顺序" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<blockquote>
<p>首先看图:<img src="../../image/Promise_study/image-20210827094130354.png" alt="image-20210827094130354"></p>
<p>可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印</p>
</blockquote>

		</div>
		<hr class="post-end">
		<footer class="post-info">
			<p>
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-tag meta-icon">
					<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
					<line x1="7" y1="7" x2="7" y2="7"></line>
				</svg><span class="tag"><a href="https://LeiBuDao.github.io/%20tags/front-end">front-end</a></span>
			</p>
			<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-file-text">
					<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
					<polyline points="14 2 14 8 20 8"></polyline>
					<line x1="16" y1="13" x2="8" y2="13"></line>
					<line x1="16" y1="17" x2="8" y2="17"></line>
					<polyline points="10 9 9 9 8 9"></polyline>
				</svg>5751 Words</p>
			<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-calendar">
					<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
					<line x1="16" y1="2" x2="16" y2="6"></line>
					<line x1="8" y1="2" x2="8" y2="6"></line>
					<line x1="3" y1="10" x2="21" y2="10"></line>
				</svg>12123-312-13 13:38 &#43;0800</p>


		</footer>
	</article>
	<aside id="toc">
		<div class="toc-title">Table of Contents</div>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#1promise是什么">1、Promise是什么?</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#2为什么要用promise">2、为什么要用Promise?</a>
      <ul>
        <li><a href="#-指定回调函数的方式更加灵活">Ⅰ-指定回调函数的方式更加灵活</a></li>
        <li><a href="#-支持链式调用-可以解决回调地狱问题">Ⅱ-支持链式调用, 可以解决回调地狱问题</a></li>
      </ul>
    </li>
    <li><a href="#3promise中的常用-api-概述">3、Promise中的常用 API 概述</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#4promise的几个关键问题">4、Promise的几个关键问题</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#5-promise的实际应用">5、 Promise的实际应用</a>
      <ul>
        <li><a href="#---加载图片">Ⅰ - 加载图片</a></li>
        <li><a href="#---generator-函数与-promise-的结合">Ⅱ - Generator 函数与 Promise 的结合</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#----基本用法">Ⅰ -  基本用法</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#----api-用法详解">Ⅱ -  API 用法详解</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#此部分可以跳过不看类似手撕源码"><strong>此部分可以跳过不看,类似手撕源码</strong></a></li>
    <li><a href="#-promise的实例方法实现">Ⅰ-Promise的实例方法实现</a>
      <ul>
        <li><a href="#1---初始结构搭建">1 - 初始结构搭建</a></li>
        <li><a href="#2---resolve-与-reject构建与基础实现">2 - resolve 与 reject构建与基础实现</a></li>
        <li><a href="#3---throw-抛出异常改变状态">3 - throw 抛出异常改变状态</a></li>
        <li><a href="#4---状态只能修改一次">4 - 状态只能修改一次</a></li>
        <li><a href="#5---then-方法执行回调基础实现">5 - then 方法执行回调基础实现</a></li>
        <li><a href="#6---异步任务-then-方法实现">6 - 异步任务 then 方法实现</a></li>
        <li><a href="#7---指定多个回调">7 - 指定多个回调</a></li>
        <li><a href="#8---同步任务-then-返回结果">8 - 同步任务 then 返回结果</a></li>
        <li><a href="#9---异步任务-then-返回结果">9 - 异步任务 then 返回结果</a></li>
        <li><a href="#10--then方法代码优化">10- then方法代码优化</a></li>
        <li><a href="#11---catch-方法与异常穿透与值传递">11 - catch 方法与异常穿透与值传递</a></li>
      </ul>
    </li>
    <li><a href="#-promise的静态方法实现">Ⅱ-Promise的静态方法实现</a>
      <ul>
        <li><a href="#1---promiseresolve-封装">1 - Promise.resolve 封装</a></li>
        <li><a href="#2---promiseresolve-封装">2 - Promise.resolve 封装</a></li>
        <li><a href="#3---promiseall-封装">3 - Promise.all 封装</a></li>
        <li><a href="#4---promiserace-封装">4 - Promise.race 封装</a></li>
      </ul>
    </li>
    <li><a href="#-其他优化">Ⅲ-其他优化</a>
      <ul>
        <li><a href="#1---回调函数异步执行">1 - 回调函数『异步执行』</a></li>
        <li><a href="#2--class改写promise">2- class改写promise</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#-async函数">Ⅰ-async函数</a></li>
    <li><a href="#-await表达式">Ⅱ-await表达式</a></li>
    <li><a href="#-注意">Ⅲ-注意</a></li>
    <li><a href="#-自己对某些问题理解解答">Ⅳ-自己对某些问题理解解答</a>
      <ul>
        <li><a href="#1如何在promise外部使用promise的结果">1、如何在Promise外部使用Promise的结果</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#-说明">Ⅰ-说明</a></li>
    <li><a href="#-代码与示例">Ⅱ-代码与示例</a>
      <ul>
        <li><a href="#1代码示例">1、代码示例:</a></li>
        <li><a href="#2示例结果">2、示例结果:</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#--出现场景">Ⅰ- 出现场景</a></li>
    <li><a href="#---尝试输入其他内容进行分析">Ⅱ - 尝试输入其他内容进行分析</a></li>
    <li><a href="#---evalstring">Ⅲ - eval（string）</a></li>
    <li><a href="#---验证一下">Ⅳ - 验证一下</a></li>
    <li><a href="#----分析其在宏任务与微任务的打印顺序">Ⅴ -  分析其在宏任务与微任务的打印顺序</a></li>
  </ul>
</nav>
	</aside>
	<div class="post-nav thin">
		<a class="next-post" href="https://LeiBuDao.github.io/posts/angular_study/">
			<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
					viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
					stroke-linejoin="round" class="feather feather-arrow-left">
					<line x1="19" y1="12" x2="5" y2="12"></line>
					<polyline points="12 19 5 12 12 5"></polyline>
				</svg>&nbsp;Newer</span><br><span>Angular_study</span>
		</a>
		<a class="prev-post" href="https://LeiBuDao.github.io/posts/ajax_study/">
			<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24"
					height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
					stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right">
					<line x1="5" y1="12" x2="19" y2="12"></line>
					<polyline points="12 5 19 12 12 19"></polyline>
				</svg></span><br><span>三小时AJAX从入门到精通</span>
		</a>
	</div>
	<div id="comments" class="thin">
</div>
</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://LeiBuDao.github.io/"> MADE BY RUNXU</a> &#183;<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"> </a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://LeiBuDao.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://LeiBuDao.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	

</body>

</html>
