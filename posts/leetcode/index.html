<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="111214">
	<meta name="msapplication-TileColor" content="111214">
<meta itemprop="name" content="Leetcode 刷题笔记">
<meta itemprop="description" content="1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 示例 1： 输入：nums = [2,7,11,15], target = 9， 输出：[0,1]
示例 2： 输入：nums = [3,2,4], target = 6， 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6， 输出：[0,1]
* 解法一 暴力法，二重循环 复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。 * 解法二 排序&#43;双指针 思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。 复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。 为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。 class Solution {public:static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){return a.first&lt;b.first;}vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {vector&lt;pair&lt;int,int&gt;&gt; vec;for(int i = 0; i &lt; nums."><meta itemprop="datePublished" content="2021-12-05T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-12-05T00:00:00+00:00" />
<meta itemprop="wordCount" content="525">
<meta itemprop="keywords" content="leetcode,datastructure,algoritjm," /><meta property="og:title" content="Leetcode 刷题笔记" />
<meta property="og:description" content="1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 示例 1： 输入：nums = [2,7,11,15], target = 9， 输出：[0,1]
示例 2： 输入：nums = [3,2,4], target = 6， 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6， 输出：[0,1]
* 解法一 暴力法，二重循环 复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。 * 解法二 排序&#43;双指针 思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。 复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。 为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。 class Solution {public:static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){return a.first&lt;b.first;}vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {vector&lt;pair&lt;int,int&gt;&gt; vec;for(int i = 0; i &lt; nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://LeiBuDao.github.io/posts/leetcode/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-12-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode 刷题笔记"/>
<meta name="twitter:description" content="1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 示例 1： 输入：nums = [2,7,11,15], target = 9， 输出：[0,1]
示例 2： 输入：nums = [3,2,4], target = 6， 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6， 输出：[0,1]
* 解法一 暴力法，二重循环 复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。 * 解法二 排序&#43;双指针 思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。 复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。 为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。 class Solution {public:static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){return a.first&lt;b.first;}vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {vector&lt;pair&lt;int,int&gt;&gt; vec;for(int i = 0; i &lt; nums."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Leetcode 刷题笔记</title>
	<link rel="stylesheet" href="https://LeiBuDao.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">


</head>

<body id="page">
	
<header id="site-header" class="animated slideInUp">
	<div class="hdr-wrapper section-inner">
		<div class="hdr-left">
			<div class="site-branding">
				<a href="https://LeiBuDao.github.io/">Run</a>
			</div>
			<nav class="site-nav hide-in-mobile">
				
				<a href="https://LeiBuDao.github.io/about-myblog/">About</a>
				<a href="https://LeiBuDao.github.io/posts/">Blogs</a>
				<a href="https://LeiBuDao.github.io/project/">Project</a>
				<a href="https://LeiBuDao.github.io/contact-me/">Contact Me</a>

			</nav>
		</div>
		<div class="hdr-right hdr-icons">
			<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg
					xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-list">
					<line x1="8" y1="6" x2="21" y2="6"></line>
					<line x1="8" y1="12" x2="21" y2="12"></line>
					<line x1="8" y1="18" x2="21" y2="18"></line>
					<line x1="3" y1="6" x2="3" y2="6"></line>
					<line x1="3" y1="12" x2="3" y2="12"></line>
					<line x1="3" y1="18" x2="3" y2="18"></line>
				</svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/LeiBuDao" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg></a><a href="https://web.telegram.org" target="_blank" rel="noopener me" title="Telegram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M21.198 2.433a2.242 2.242 0 0 0-1.022.215l-8.609 3.33c-2.068.8-4.133 1.598-5.724 2.21a405.15 405.15 0 0 1-2.849 1.09c-.42.147-.99.332-1.473.901-.728.968.193 1.798.919 2.286 1.61.516 3.275 1.009 4.654 1.472.509 1.793.997 3.592 1.48 5.388.16.36.506.494.864.498l-.002.018s.281.028.555-.038a2.1 2.1 0 0 0 .933-.517c.345-.324 1.28-1.244 1.811-1.764l3.999 2.952.032.018s.442.311 1.09.355c.324.022.75-.04 1.116-.308.37-.27.613-.702.728-1.196.342-1.492 2.61-12.285 2.997-14.072l-.01.042c.27-1.006.17-1.928-.455-2.474a1.654 1.654 0 0 0-1.034-.407z" />
</svg></a><a href="https://instagram.com/" target="_blank" rel="noopener me" title="Instagram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
    <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
    <line x1="17.5" y1="6.5" x2="17.5" y2="6.5"></line>
</svg></a><a href="https://space.bilibili.com/438672729" target="_blank" rel="noopener me" title="Bilibili"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24"
    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg"
					width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
					stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
					<line x1="3" y1="12" x2="21" y2="12"></line>
					<line x1="3" y1="6" x2="21" y2="6"></line>
					<line x1="3" y1="18" x2="21" y2="18"></line>
				</svg></button>
		</div>
	</div>

</header>
<div id="mobile-menu" class="animated fast">
	<ul>
		<li><a href="https://LeiBuDao.github.io/about-myblog/">About</a></li>
		<li><a href="https://LeiBuDao.github.io/posts/">Blogs</a></li>
		<li><a href="https://LeiBuDao.github.io/project/">Project</a></li>
		<li><a href="https://LeiBuDao.github.io/contact-me/">Contact Me</a></li>
	</ul>
</div>

<main class="site-main section-inner animated fadeIn faster">
	<article class="thin">
		<header class="post-header">
			<div class="post-meta"><span>Dec 5, 2021</span></div>
			<h1>Leetcode 刷题笔记</h1>
		</header>
		<div class="content">
			<h1 id="1两数之和"><strong>1.两数之和</strong><a href="#1两数之和" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<h2 id="题目给定一个整数数组-nums和一个整数目标值-target请你在该数组中找出和为目标值-target的那两个整数并返回它们的数组下标">题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。<a href="#题目给定一个整数数组-nums和一个整数目标值-target请你在该数组中找出和为目标值-target的那两个整数并返回它们的数组下标" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9，
输出：[0,1]</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums = [3,2,4], target = 6，
输出：[1,2]</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums = [3,3], target = 6，
输出：[0,1]</p>
</blockquote>
<hr>
<h2 id="-解法一">* <em>解法一</em><a href="#-解法一" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="暴力法二重循环">暴力法，二重循环<a href="#暴力法二重循环" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>复杂度：暴力算法时间复杂度O（n²），空间复杂度O（1）。</li>
</ul>
<h2 id="-解法二">* <em>解法二</em><a href="#-解法二" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="排序双指针">排序+双指针<a href="#排序双指针" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>思想：用一个pair数组vec储存nums的内容（first）以及下标（second）。根据first中从小到大排序，最后利用双指针遍历数组进行匹配，返回对应的second中的内容，即数组下标。</li>
<li>复杂度：这里先将数组排序好O（nlogn），再利用双指针法遍历一遍O（n）得到结果。
为了保存下标信息另开了一个数组。时间复杂度O（nlogn），空间复杂度O（n）。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    static bool cmp(const pair&lt;int,int&gt;a,const pair&lt;int,int&gt;b){
        return a.first&lt;b.first;
    }
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;pair&lt;int,int&gt;&gt; vec;
        for(int i = 0; i &lt; nums.size(); i++){
            vec.push_back(make_pair(nums[i],i));
        }
        sort(vec.begin(),vec.end(),cmp);
        int i = 0,j = nums.size()-1;
        while(i&lt;j){
            if(vec[i].first+vec[j].first&gt;target) {
                j--;
            }
            else if(vec[i].first+vec[j].first&lt;target) {
                i++;
            }
            else if(vec[i].first+vec[j].first==target) { 
                return {vec[i].second,vec[j].second};
            }
        }
        return {};
    }
};
</code></pre>
<h2 id="-解法三">* <em>解法三</em><a href="#-解法三" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="hash表">Hash表<a href="#hash表" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>思想：创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</li>
<li>复杂度：
<ul>
<li>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以O(1)地寻找 target - x。</li>
<li>空间复杂度：O(n)，其中 n 是数组中的元素数量,主要为哈希表的开销。</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashtable;
        for (int i = 0; i &lt; nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it-&gt;second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<h1 id="88合并两个有序数组"><strong>88.合并两个有序数组</strong><a href="#88合并两个有序数组" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h1>
<h2 id="题目-给你两个按非递减顺序排列的整数数组nums1-和-nums2另有两个整数-m-和-n-分别表示-nums1-和-nums2-中的元素数目请你合并nums2-到-nums1-中使合并后的数组同样按非递减顺序排列"><em><strong>题目：</strong></em> 给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。<a href="#题目-给你两个按非递减顺序排列的整数数组nums1-和-nums2另有两个整数-m-和-n-分别表示-nums1-和-nums2-中的元素数目请你合并nums2-到-nums1-中使合并后的数组同样按非递减顺序排列" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h2 id="注意--最终合并后数组不应由函数返回而是存储在数组-nums1-中为了应对这种情况nums1-的初始长度为-m--n其中前-m-个元素表示应合并的元素后-n-个元素为-0-应忽略nums2-的长度为-n-"><em><strong>注意：</strong></em>  最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。<a href="#注意--最终合并后数组不应由函数返回而是存储在数组-nums1-中为了应对这种情况nums1-的初始长度为-m--n其中前-m-个元素表示应合并的元素后-n-个元素为-0-应忽略nums2-的长度为-n-" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<ul>
<li>示例 1：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3。<br>
输出：[1,2,2,3,5,6]<br>
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p>
</blockquote>
<ul>
<li>示例 2：</li>
</ul>
<blockquote>
<p>输入：nums1 = [1], m = 1, nums2 = [], n = 0 。<br>
输出：[1]。<br>
解释：需要合并 [1] 和 [] 。合并结果是 [1] 。</p>
</blockquote>
<ul>
<li>示例 3：</li>
</ul>
<blockquote>
<p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1 。<br>
输出：[1]  。<br>
解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
</blockquote>
<h2 id="-解法一-1">* <em>解法一</em><a href="#-解法一-1" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="合并后直接排序">合并后直接排序<a href="#合并后直接排序" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O((m+n)log(m+n))
排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)\log(m+n))</p>
</li>
<li>
<p>空间复杂度：O(log(m+n))。
排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(\log(m+n))O(log(m+n))。</p>
</li>
</ul>
</li>
</ul>
<h2 id="-解法二-1">* <em>解法二</em><a href="#-解法二-1" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="双指针归并">双指针归并<a href="#双指针归并" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>复杂度：
<ul>
<li>
<p>时间复杂度：O(m+n)。
指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。</p>
</li>
<li>
<p>空间复杂度：O(m+n)。
需要建立长度为 m+n 的中间数组 sorted。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = 0, p2 = 0;
        int sorted[m + n];
        int cur;
        while (p1 &lt; m || p2 &lt; n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] &lt; nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
};
</code></pre>
<h2 id="-解法三-1">* <em>解法三</em><a href="#-解法三-1" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h2>
<h3 id="逆向双指针">逆向双指针<a href="#逆向双指针" class="anchor"
					aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
						<line x1="8" y1="12" x2="16" y2="12"></line>
					</svg></a></h3>
<ul>
<li>算法思想： 通过题意所示，我们可以使用暴破，双指针+额外存储空间来完成该题，但是这两种做法的空间和时间复杂度至少都是 O(m + n) 。这个时候我们就要分析，为什么告诉我们 nums1.length &gt;= m + n，很明显就能猜出出题者的意图，那就是考查原地修改，将空间复杂度降低到 O(1)。因为这样不需要使用额外的数组空间了，我们完全可以把 nums2 也放入 nums1 中。原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择从后往前遍历！所以，我们总共需要创建三个指针，两个指针用于指向 nums1 和 nums2 的初始化元素数量的末位，也就是分别指向 m-1 和 n-1 的位置，还有一个指针，我们指向 nums1 数组末位即可。</li>
</ul>
<blockquote>
</blockquote>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 &gt;= 0 || p2 &gt;= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] &gt; nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
};
</code></pre>

		</div>
		<hr class="post-end">
		<footer class="post-info">
			<p>
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-tag meta-icon">
					<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
					<line x1="7" y1="7" x2="7" y2="7"></line>
				</svg><span class="tag"><a href="https://LeiBuDao.github.io/%20tags/leetcode">leetcode</a></span><span class="tag"><a href="https://LeiBuDao.github.io/%20tags/datastructure">datastructure</a></span><span class="tag"><a href="https://LeiBuDao.github.io/%20tags/algoritjm">algoritjm</a></span>
			</p>
			<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-file-text">
					<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
					<polyline points="14 2 14 8 20 8"></polyline>
					<line x1="16" y1="13" x2="8" y2="13"></line>
					<line x1="16" y1="17" x2="8" y2="17"></line>
					<polyline points="10 9 9 9 8 9"></polyline>
				</svg>525 Words</p>
			<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
					class="feather feather-calendar">
					<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
					<line x1="16" y1="2" x2="16" y2="6"></line>
					<line x1="8" y1="2" x2="8" y2="6"></line>
					<line x1="3" y1="10" x2="21" y2="10"></line>
				</svg>50512-125-0 08:00 &#43;0800</p>


		</footer>
	</article>
	<aside id="toc">
		<div class="toc-title">Table of Contents</div>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#题目给定一个整数数组-nums和一个整数目标值-target请你在该数组中找出和为目标值-target的那两个整数并返回它们的数组下标">题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</a></li>
    <li><a href="#-解法一">* <em>解法一</em></a>
      <ul>
        <li><a href="#暴力法二重循环">暴力法，二重循环</a></li>
      </ul>
    </li>
    <li><a href="#-解法二">* <em>解法二</em></a>
      <ul>
        <li><a href="#排序双指针">排序+双指针</a></li>
      </ul>
    </li>
    <li><a href="#-解法三">* <em>解法三</em></a>
      <ul>
        <li><a href="#hash表">Hash表</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#题目-给你两个按非递减顺序排列的整数数组nums1-和-nums2另有两个整数-m-和-n-分别表示-nums1-和-nums2-中的元素数目请你合并nums2-到-nums1-中使合并后的数组同样按非递减顺序排列"><em><strong>题目：</strong></em> 给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。</a></li>
    <li><a href="#注意--最终合并后数组不应由函数返回而是存储在数组-nums1-中为了应对这种情况nums1-的初始长度为-m--n其中前-m-个元素表示应合并的元素后-n-个元素为-0-应忽略nums2-的长度为-n-"><em><strong>注意：</strong></em>  最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</a></li>
    <li><a href="#-解法一-1">* <em>解法一</em></a>
      <ul>
        <li><a href="#合并后直接排序">合并后直接排序</a></li>
      </ul>
    </li>
    <li><a href="#-解法二-1">* <em>解法二</em></a>
      <ul>
        <li><a href="#双指针归并">双指针归并</a></li>
      </ul>
    </li>
    <li><a href="#-解法三-1">* <em>解法三</em></a>
      <ul>
        <li><a href="#逆向双指针">逆向双指针</a></li>
      </ul>
    </li>
  </ul>
</nav>
	</aside>
	<div class="post-nav thin">
		<a class="next-post" href="https://LeiBuDao.github.io/posts/safinalexam/">
			<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
					viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
					stroke-linejoin="round" class="feather feather-arrow-left">
					<line x1="19" y1="12" x2="5" y2="12"></line>
					<polyline points="12 19 5 12 12 5"></polyline>
				</svg>&nbsp;Newer</span><br><span>软件体系结构期末复习</span>
		</a>
	</div>
	<div id="comments" class="thin">
</div>
</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://LeiBuDao.github.io/"> MADE BY RUNXU</a> &#183;<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"> </a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://LeiBuDao.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://LeiBuDao.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	

</body>

</html>
